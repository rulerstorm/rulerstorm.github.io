<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Rock&#39;s personal notebook</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://Rocklu.me/"/>
  <updated>2016-11-16T18:06:09.000Z</updated>
  <id>http://Rocklu.me/</id>
  
  <author>
    <name>Rock Lu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Git Notes</title>
    <link href="http://Rocklu.me/2016/08/14/Git%E7%89%88%E6%9C%AC%E5%9B%9E%E9%80%80/"/>
    <id>http://Rocklu.me/2016/08/14/Git版本回退/</id>
    <published>2016-08-13T16:00:00.000Z</published>
    <updated>2016-11-16T18:06:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>draft, need to be orgnized</p>
<h4 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h4><p>commit <code>changes</code> from staging area, instead of files<br>-a will commit changes from staging area and working dir, but that file should be tracked<br>–amend, amend last commit, <code>local only</code>, do not do amend after push</p>
<h4 id="git-checkout-gt-walk-around-in-commits-and-branchs"><a href="#git-checkout-gt-walk-around-in-commits-and-branchs" class="headerlink" title="git checkout =&gt; walk around in commits and branchs"></a>git checkout =&gt; walk around in commits and branchs</h4><pre><code>1. checkout &lt;commit&gt;
2. checkout &lt;commit&gt; &lt;file&gt;
3. branch
&gt; only change working dirs
</code></pre><h4 id="git-revert"><a href="#git-revert" class="headerlink" title="git revert"></a>git revert</h4><p>create a new commit to pretend a roll back. safe command.</p>
<h4 id="git-reset-gt-delet-history"><a href="#git-reset-gt-delet-history" class="headerlink" title="git reset =&gt; delet history"></a>git reset =&gt; delet history</h4><pre><code>1. git reset &lt;file&gt;  =&gt; unstaging
    clean up staging area, but leave working directory unchanged
    --hard will also reset working directory to match last commit
2. git reset &lt;commit&gt;
    unstaging + remove commits
    --hard will also reset working directory
</code></pre><blockquote>
<p>do not reset to the commit after a push, use revert! reset is used locally only.<br>danger, reset can’t undo even via reflog!</p>
</blockquote>
<h4 id="compare-them"><a href="#compare-them" class="headerlink" title="compare them"></a>compare them</h4><p>checkout just changes the working dir<br>reset removes the commits<br>revert adds a commit to perform like a roll back<br><code>above three comman only affet tracked files.</code></p>
<h4 id="git-clean-gt-remove-untracked-files"><a href="#git-clean-gt-remove-untracked-files" class="headerlink" title="git clean =&gt; remove untracked files"></a>git clean =&gt; remove untracked files</h4><p>always need -f to perform<br>need -d to delete dirs<br>will not delete files listed in .gitignore</p>
<h4 id="git-rebase-gt-facilitates-a-fast-forward-merge"><a href="#git-rebase-gt-facilitates-a-fast-forward-merge" class="headerlink" title="git rebase =&gt; facilitates a fast-forward merge"></a>git rebase =&gt; facilitates a fast-forward merge</h4><p>–rebase -i =&gt; squash history</p>
<h4 id="git-reflog-gt-contains-the-history-about-rollback"><a href="#git-reflog-gt-contains-the-history-about-rollback" class="headerlink" title="git reflog =&gt; contains the history about rollback"></a>git reflog =&gt; contains the history about rollback</h4>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;draft, need to be orgnized&lt;/p&gt;
&lt;h4 id=&quot;git-commit&quot;&gt;&lt;a href=&quot;#git-commit&quot; class=&quot;headerlink&quot; title=&quot;git commit&quot;&gt;&lt;/a&gt;git commit&lt;/h4&gt;&lt;p&gt;comm
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CPP异常处理</title>
    <link href="http://Rocklu.me/2016/03/28/CPP%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>http://Rocklu.me/2016/03/28/CPP异常处理/</id>
    <published>2016-03-27T16:00:00.000Z</published>
    <updated>2016-03-29T09:31:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>对于可以预计的问题，相对于原始的<code>if判断</code>与<code>返回值</code>方法，异常处理机制的主要目的，是「把问题的<code>检测</code>与<code>处理</code>分离」，相互独立以后，可以降低耦合度，且相互不需要知道内部细节。</p>
<a id="more"></a>
<h4 id="栈展开-stack-unwinding"><a href="#栈展开-stack-unwinding" class="headerlink" title="栈展开(stack unwinding)"></a>栈展开(stack unwinding)</h4><p>每个函数/代码块（function/block）被调用时，会把局部变量压栈。<br>然而当异常被throw后，当前栈就直接释放，搜寻是否有匹配的catch。<br>如果当前的try块的catch不能匹配，则再<code>退栈</code>，返回上一层函数，搜索匹配的catch。直到有catch接住这个异常为止。<br>这个过程就是栈展开。<br>我们需要注意的是：</p>
<ol>
<li>退栈的情况和<code>函数调用</code>完毕后的退栈情况一样，不要传出局部变量的引用或指针</li>
<li>抛出异常时，代码的行为类似于<code>return</code>，后面的代码都不执行。于是才用RAII管理资源是必须的。</li>
<li>[不重要]退栈的过程中清理局部变量，会调用析构函数。所以，析构函数一般不抛异常。如果你要抛，自己处理掉。否则直接terminate。</li>
</ol>
<h4 id="异常对象"><a href="#异常对象" class="headerlink" title="异常对象"></a>异常对象</h4><p>异常对象可以是标准库里面的exception类型，也可以是任意的类型。因为退栈，局部变量都会被销毁，这个对象要能让很多层以外的调用者知道是什么东西出了问题。<br>STL里面的类型大致分两种：runtime_error和logic_error<br>runtime主要是溢出、越界。指运行时错误。<br>logic主要是参数错误、范围错误。指代码的错误。</p>
<p><code>「注意」</code>为了满足退栈后别人还能访问到这个对象的特性，异常对象被存放在编译器管理的内存空间中。在catch语句结束后销毁。</p>
<h4 id="异常的捕获"><a href="#异常的捕获" class="headerlink" title="异常的捕获"></a>异常的捕获</h4><p>可以说，catch是一种特殊的函数。根据被抛出的异常对象的类型，编译器裁决是否符合catch函数对参数的要求。catch语句与普通的<code>函数调用</code>的主要区别如下：<br>函数调用裁决时，允许最大限度的<code>类型转化</code>。而catch则非常严格，只允许<strong>子类到父类</strong>、<strong>变量到常量</strong>、<strong>数组函数名转指针</strong>这三种类型转化。<br>另外：</p>
<ol>
<li>异常对象的形参，和函数形参相似，也是使用「拷贝初始化」的方式初始化的。所以，这个异常类如果是自己定义的，必须小心「拷贝构造」函数。</li>
<li>和函数调用一样，<code>引用类型</code>的参数会直接操作全局的异常对象。</li>
</ol>
<h4 id="额外的主题"><a href="#额外的主题" class="headerlink" title="额外的主题"></a>额外的主题</h4><p><strong>rethrowing</strong><br>对于不能完全处理的异常，可以处理一部分，然后再向上抛。语法就是只写一个<code>throw;</code><br><strong>捕获所有异常</strong><br>catch函数类型要求严格，想要一个函数接住所有，这样：<code>catch(...)</code>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于可以预计的问题，相对于原始的&lt;code&gt;if判断&lt;/code&gt;与&lt;code&gt;返回值&lt;/code&gt;方法，异常处理机制的主要目的，是「把问题的&lt;code&gt;检测&lt;/code&gt;与&lt;code&gt;处理&lt;/code&gt;分离」，相互独立以后，可以降低耦合度，且相互不需要知道内部细节。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>博客迁移</title>
    <link href="http://Rocklu.me/2016/03/21/%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB/"/>
    <id>http://Rocklu.me/2016/03/21/博客迁移/</id>
    <published>2016-03-20T16:00:00.000Z</published>
    <updated>2016-03-30T14:23:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前的一年里，虽然陆陆续续从各方面开始感觉jekyll不好使，也因为凑合用，就一直懒得换。<br>直到最近github开始不兼容我原来那个模板的语法…随便补救一下之后发现新旧不兼容，今天更是无法编译我最新的文章了…</p>
<p>无奈。换吧，试试hexo~</p>
<a id="more"></a>
<p>想不到坑真是非常的多。。。</p>
<h4 id="首先，之前语法高亮的标记-highlight-cpp-要全部替换"><a href="#首先，之前语法高亮的标记-highlight-cpp-要全部替换" class="headerlink" title="首先，之前语法高亮的标记\{\% highlight cpp \%\}要全部替换"></a>首先，之前语法高亮的标记<code>\{\% highlight cpp \%\}</code>要全部替换</h4><p>正好复习了下正则表达式，命令如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ls | xargs sed -i.backup.md <span class="string">'s/&#123;%.*highlight *\(.*\) *%&#125;/```\1/g'</span></div></pre></td></tr></table></figure></p>
<h4 id="其次，hexo语法奇葩，行尾不能有空格"><a href="#其次，hexo语法奇葩，行尾不能有空格" class="headerlink" title="其次，hexo语法奇葩，行尾不能有空格"></a>其次，hexo语法奇葩，行尾不能有空格</h4><p>于是：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ls | xargs sed -i.backup.md <span class="string">'s/ *$//g'</span></div></pre></td></tr></table></figure></p>
<h4 id="再来，是图片的地址"><a href="#再来，是图片的地址" class="headerlink" title="再来，是图片的地址"></a>再来，是图片的地址</h4><p>之前放在github文件夹里面，现在迁移到七牛，需要改改前缀。<br>于是打开VIM：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:%s/PATERN/TARGET/</div></pre></td></tr></table></figure></p>
<p>需要注意的是http地址里面的斜杠<code>/</code>在pattern里面需要用转义<code>\/</code>。</p>
<h4 id="最后，你需要熟悉hexo的生态"><a href="#最后，你需要熟悉hexo的生态" class="headerlink" title="最后，你需要熟悉hexo的生态"></a>最后，你需要熟悉hexo的生态</h4><p><strong>简单命令</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">g == generate</div><div class="line">s == serve</div><div class="line">d == deploy 部署至github需要插件和配置</div><div class="line">g -<span class="_">-d</span> == generate + deploy</div><div class="line">clean == flush buffer</div></pre></td></tr></table></figure></p>
<p><strong>配置</strong><br>主要看官方文档，这里写思路</p>
<ol>
<li>安装模板，git上clone到模板文件夹，然后到配置文件里面设置</li>
<li>根据模板要求安装各种插件，关键还有deploy到github的插件</li>
<li>然后在主配置文件里面设置好github账户，OK！</li>
</ol>
<p><strong>另外</strong><br>CNAME文件放在<code>source</code>目录下，只有这个文件夹下的内容会被push出去。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前的一年里，虽然陆陆续续从各方面开始感觉jekyll不好使，也因为凑合用，就一直懒得换。&lt;br&gt;直到最近github开始不兼容我原来那个模板的语法…随便补救一下之后发现新旧不兼容，今天更是无法编译我最新的文章了…&lt;/p&gt;
&lt;p&gt;无奈。换吧，试试hexo~&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>C++零碎笔记</title>
    <link href="http://Rocklu.me/2016/03/20/C++%E9%9B%B6%E7%A2%8E%E7%AC%94%E8%AE%B0/"/>
    <id>http://Rocklu.me/2016/03/20/C++零碎笔记/</id>
    <published>2016-03-19T16:00:00.000Z</published>
    <updated>2016-03-31T03:03:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>补充零碎的cpp笔记。</p>
<a id="more"></a>
<h4 id="堆和栈"><a href="#堆和栈" class="headerlink" title="堆和栈"></a>堆和栈</h4><ul>
<li>局部变量的内存分配在栈上，出了大括号自动清理。</li>
<li>new出来的变量分配在堆上，需要手动释放。</li>
</ul>
<blockquote>
<p>问：既然栈内存可以自动释放，为啥还要堆呢？<br>因为每个函数的栈大小，是在<code>编译期</code>就确定下来的，代码写好就钉死了。（这也是为什么申明数组时不可以使用变量）这个函数执行结束后，把这块固定大小的栈空间释放掉。所以，对于需要在<code>运行时</code>确定大小的空间，就要有一个灵活的堆来管理。</p>
</blockquote>
<h4 id="构造函数的调用顺序"><a href="#构造函数的调用顺序" class="headerlink" title="构造函数的调用顺序"></a>构造函数的调用顺序</h4><p>由于「子类包含父类」，或者说，父类是子类的前面一部分。于是，构造时，从里面开始，先调用父类，再调用子类。<br>同理，对于一个类里面「持有」另一个类的情况，也是先构造里面的类。<br>同理，对于析构函数，先析构外面的子类，再析构里面。</p>
<h4 id="操作符重载若干问题"><a href="#操作符重载若干问题" class="headerlink" title="操作符重载若干问题"></a>操作符重载若干问题</h4><ol>
<li>操作符重载可以写在类里，也可以写在全局。但是优先调用全局的。</li>
<li>对于「指针」操作符的重载（即<code>-&gt;</code>），语法规定就是返回一个raw pointer类型（<code>*</code>，或者说是地址）。不要追问<code>为什么这个-&gt;不是唤起重载函数用掉了吗？为什么又能继续作用到后面的东西呢？</code>，因为这是语法规定。</li>
<li>对于<code>i++</code>的重载，就是有一个「虚置」的int放在那里，用来区分<code>++i</code>的重载函数。语法规定，没理由。</li>
</ol>
<h4 id="再谈explicit关键字"><a href="#再谈explicit关键字" class="headerlink" title="再谈explicit关键字"></a>再谈explicit关键字</h4><p>要知道，编译器的主要工作，是尽可能帮你通过编译。（真的嘛？…）<br>作为<code>弱类型</code>语言，C++编译器会寻找各种「隐式类型转化」来帮助代码通过编译。一个明显的例子就是当你把一个int放到申明参数为double的函数里面去时，代码不会报错。<br>当你写了一个class，他的构造函数只有<code>一个参数</code>，或者其他的参数都有默认值时，编译器会根据代码需要，自动帮你把符合构造函数的变量，给他套上这个构造函数。正是因为这样的特性，编译器有时会意外得帮你做出你不需要的转化。而「explicit」的意思就是：明确的、显式的。意思就是只有我明确写了我要调用这个构造函数时，你才调用。否则别帮我自作多情。</p>
<blockquote>
<p>那，为啥只有<code>一个参数</code>的构造函数才有这种问题呢？<br>答，很显然，你俩参数，出了显式调用，还能咋自动？</p>
</blockquote>
<h4 id="泛型编程若干"><a href="#泛型编程若干" class="headerlink" title="泛型编程若干"></a>泛型编程若干</h4><p><strong>概述：</strong><br>模板有三种：<code>函数模板</code>、<code>类模板</code>、<code>成员模板</code>。<br>其中，仅有类模板需要在绑定时显示绑定模板参数，其余两个可以编译时自动推断。</p>
<blockquote>
<p>问：有了类模板不就行了，还要成员模板干啥呢？<br>答：首先要明确：成员模板–指的是成员函数是一个「模板函数」。<br>也就是说，即使在模板类绑定了参数以后，仍然允许其成员函数接受泛型参数。（即构造函数参数类型未定）。<br>如果只用类模板，在class的参数绑定以后，函数参数的类型也绑定了，不能改了。<br>_<br>用途：多用在STL的<code>copy构造函数</code>。比如，希望可以支持<code>用子类copy初始化父类</code>。虽然把参数定义为父类指针也可以做到这件事情，但是要知道，父类本身就是一个类模板，类型未定，在写这个函数的时候是不能决定参数类型的。</p>
</blockquote>
<p><strong>关于「模板模板参数」</strong><br>意思是，参数本身是一个<code>未绑定的</code>「模板类」。已经绑定的模板类作为参数不属于模板模板参数。<br>暂时并不能理解这样做的好处，可能是强制根据其他参数自动绑定。</p>
<hr>
<h4 id="虚表与虚指针"><a href="#虚表与虚指针" class="headerlink" title="虚表与虚指针"></a>虚表与虚指针</h4>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;补充零碎的cpp笔记。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>内存对齐浅析</title>
    <link href="http://Rocklu.me/2016/02/14/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E6%B5%85%E6%9E%90/"/>
    <id>http://Rocklu.me/2016/02/14/内存对齐浅析/</id>
    <published>2016-02-13T16:00:00.000Z</published>
    <updated>2016-03-29T09:31:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>这个概念经常听到，好像也不难。但是稍微想一下，就发现并不是一两句话能够带过的。</p>
<a id="more"></a>
<h4 id="啥是「字节对齐」？"><a href="#啥是「字节对齐」？" class="headerlink" title="啥是「字节对齐」？"></a>啥是「字节对齐」？</h4><p>变量放在内存中，以<code>起始位置</code>作为地址。内存对齐，就是把内存分出一个个的<code>“槽”</code>，看上去和分页差不多，称为对齐。</p>
<h4 id="为啥要对齐？"><a href="#为啥要对齐？" class="headerlink" title="为啥要对齐？"></a>为啥要对齐？</h4><p>现代机器虽然是「按字节编址」，理论上可以访问任意一个字节。但是，<code>somehow</code>32位机器通过地址总线访问内存时，总是从4Btye的<code>整数倍</code>位置开始。我们知道对于<code>字长</code>也是32位（4Byte）的计算机来说，一次读取的数据量就是4Byte。于是乎，如果一个Int型（4B）的数据，没有放在能被4B整除的位置，那么就需要访问两次（一前一后），才能拼出这个Int数据。所以，是<code>效率问题</code>。<br>「另外」在MIPS机器上不对齐会报错。<br>「水深」字节对齐不但牵涉硬件，还有关大小端、强制转化等隐蔽错误！<br>「关于那个somehow」网上看了很多资料，都没有很好从硬件上解释CPU为何会先从4B的整数位置开始，只能somehow了。。。</p>
<h4 id="对齐规则"><a href="#对齐规则" class="headerlink" title="对齐规则"></a>对齐规则</h4><p>非常类似于「内存分页」。规则如下：</p>
<ol>
<li>变量长度<code>大于等于</code>4B的，一律另开一个槽（页），从4B的整数地址开始。</li>
<li>变量长度<code>小于</code>4B的，先试下能否直接在前面变量的槽里塞下，塞的下就塞进去。塞不下就另开一个槽。</li>
</ol>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> A&#123;</div><div class="line">	<span class="keyword">char</span> a;</div><div class="line">	<span class="keyword">short</span> b;</div><div class="line">	<span class="keyword">int</span> c;</div><div class="line">&#125;;   <span class="comment">//sizeof为8</span></div><div class="line"></div><div class="line"><span class="keyword">struct</span> B&#123;</div><div class="line">	<span class="keyword">char</span> a;</div><div class="line">	<span class="keyword">int</span> c;</div><div class="line">	<span class="keyword">short</span> b;</div><div class="line">&#125;;   <span class="comment">//sizeof为12</span></div></pre></td></tr></table></figure>
<h4 id="写在最后：对齐方式可以改吗？"><a href="#写在最后：对齐方式可以改吗？" class="headerlink" title="写在最后：对齐方式可以改吗？"></a>写在最后：对齐方式可以改吗？</h4><p>当然可以的，改大了浪费空间，改小了影响效率，一般就是默认就行了。<br>默认值一般是CPU的字长。<br>修改方式：<br><code>#pragma pack(4) //按4字节对齐</code></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个概念经常听到，好像也不难。但是稍微想一下，就发现并不是一两句话能够带过的。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>OS和OSX小技巧</title>
    <link href="http://Rocklu.me/2016/02/02/iOS%E5%92%8COSX%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <id>http://Rocklu.me/2016/02/02/iOS和OSX小技巧/</id>
    <published>2016-02-01T16:00:00.000Z</published>
    <updated>2016-10-03T05:34:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>花了一段时间积累的，不容易找到，也不容易发现的tricks。</p>
<a id="more"></a>
<h4 id="如何群发短信和邮件"><a href="#如何群发短信和邮件" class="headerlink" title="如何群发短信和邮件"></a>如何群发短信和邮件</h4><ol>
<li>用mac给通讯录分组（iOS不支持）</li>
<li>在短信和mail「编辑界面」的「地址栏」<code>直接输入</code>分组的名字（不要点右边那个+号，那样会变成一个一个人选择）</li>
</ol>
<h4 id="typing时，用3D-touch移动光标"><a href="#typing时，用3D-touch移动光标" class="headerlink" title="typing时，用3D-touch移动光标"></a>typing时，用3D-touch移动光标</h4><ol>
<li>按下一个键</li>
<li>停顿0.5秒（必须）</li>
<li>用力按下（peep的力量）</li>
<li>此时键盘上的文字会消失，变成「触摸板模式」，移动手指可移动光标。</li>
<li>怎么「选择文字」？在触摸板模式，让光标在一个单词上<code>停留1秒</code>。此时开始「选择文字模式」，再移动光标就会选字了。</li>
</ol>
<h4 id="3D-touch的app切换"><a href="#3D-touch的app切换" class="headerlink" title="3D-touch的app切换"></a>3D-touch的app切换</h4><p>我们知道按压左侧屏幕会进入「任务切换」模式，此时如果不松手，而是<code>把当前app画面继续推到「最右边」推出屏幕</code>，则会直接切换到前一个app，不用选择。</p>
<h4 id="双手操作MacBook触控板"><a href="#双手操作MacBook触控板" class="headerlink" title="双手操作MacBook触控板"></a>双手操作MacBook触控板</h4><p>当需要大量「拖动」操作时，无论是「三指拖移」还是forceTouch的用力按压都会显得力不从心。此时，可以用左手按住触控板不动，右手轻轻拖移，此时右手可以随意拖移，只要左手压在那里，鼠标就不会放开。<br>「注意」左手必须压在触控板的<code>边缘</code>部位，否则无效。</p>
<h4 id="如何把照片快速弄成PDF"><a href="#如何把照片快速弄成PDF" class="headerlink" title="如何把照片快速弄成PDF"></a>如何把照片快速弄成PDF</h4><ol>
<li>同时选中多张图片</li>
<li>用「预览」（preview）打开</li>
<li>全选左侧所有的图片</li>
<li>在「菜单」中，依次「File」-&gt;「Print」-&gt;左下角有个写着<code>PDF</code>的下拉菜单 -&gt;选择「save as PDF」<br>「注意」其他方式均会导致PDF里面只有一张图！（比如export as PDF）<br>「另外」对于需要批量旋转的照片，推荐用<code>Automator</code>，简单。</li>
</ol>
<h4 id="连拍"><a href="#连拍" class="headerlink" title="连拍"></a>连拍</h4><p>iOS相机的拍照键<code>长按</code>即可以非常高的速度连拍。</p>
<h4 id="截图进阶"><a href="#截图进阶" class="headerlink" title="截图进阶"></a>截图进阶</h4><ol>
<li><code>command + shift + 4</code> 按好后，再按一下<code>空格</code>，可进入「截取窗口」模式，自带窗口阴影</li>
<li>快捷键按的时候带上<code>control</code>键，则会把截图直接存入「粘贴版」</li>
<li>改变截图的默认格式，输入命令：<code>defaults write com.apple.screencapture type jpg</code>，即可改为jpg</li>
</ol>
<h4 id="iCloud备份一直失败"><a href="#iCloud备份一直失败" class="headerlink" title="iCloud备份一直失败"></a>iCloud备份一直失败</h4><p>请使用<code>另一台</code>iOS设备进入「iCloud存储空间」管理，把faulty equipment的备份<code>删除</code>。重新备份即可。</p>
<h4 id="离线单词发音"><a href="#离线单词发音" class="headerlink" title="离线单词发音"></a>离线单词发音</h4><p>在terminal中，命令<code>say</code>可以直接念句子。如需支持中文，请在设置的「dictation and speech」栏目中下载语音包。</p>
<h4 id="Mac-OS-X-输入法技巧"><a href="#Mac-OS-X-输入法技巧" class="headerlink" title="Mac OS X 输入法技巧"></a>Mac OS X 输入法技巧</h4><p><strong>Mac OSX输入单词补全</strong><br>输入英文单词时，按下<code>ESC</code>。</p>
<p><strong>emoji输入</strong><br><code>control ＋ command ＋ 空格</code></p>
<p><strong>特殊注音词</strong><br>用 ‘ 符号作为拼音之间的分隔符，例如：xi’an 西安；<br>「tab」 可以在 1234 声调中切换选择。</p>
<p><strong>删除错误的词库</strong><br>错误的个人候选词，高亮候选词后按 「shift+delete」键。</p>
<hr>
<h4 id="emacs快捷键"><a href="#emacs快捷键" class="headerlink" title="emacs快捷键"></a>emacs快捷键</h4><p>OS X系统在大多数app中都支持emacs快捷键，包括鼠标双击、三击。<br><code>control + f</code> — forward<br><code>control + b</code> — backward<br><code>control + p</code> — previous line<br><code>control + n</code> — next line<br><code>control + a</code> — 移至行首/ command + 右<br><code>control + e</code> — 移至行尾/ command + 左<br><code>移动时按option</code> — 按照单词移动</p>
<p><code>control + d</code> — delete（删右边）<br><code>control + h</code> — delete<br><code>control + k</code> — kill（删至行尾）</p>
<p><code>control + u</code> — 全部剪切<br><code>control + y</code> — 粘贴</p>
<h4 id="我自己改的快捷键："><a href="#我自己改的快捷键：" class="headerlink" title="我自己改的快捷键："></a>我自己改的快捷键：</h4><p><code>command + shift + x</code>  —  在该文件夹打开terminal<br><code>command + shift + a</code>  —  在字典搜索该单词<br><code>alt + 1</code> — 呼出dropzone<br><code>alt + 2</code> — 呼出Moom<br><code>alt + 3</code> — 呼出iTranslate</p>
<blockquote>
<p>[系统功能]快捷键定义方法：系统偏好设置-&gt;键盘-&gt;快捷键-&gt;服务</p>
</blockquote>
<h4 id="Mac外接显示器分辨率的问题"><a href="#Mac外接显示器分辨率的问题" class="headerlink" title="Mac外接显示器分辨率的问题"></a>Mac外接显示器分辨率的问题</h4><p>在Display设置中，scale选项下有多个分辨率可选。此时按下<code>Option</code>键会出现更多选项。option键可在多处打开隐藏选项。</p>
<hr>
<h4 id="使用openssl加密"><a href="#使用openssl加密" class="headerlink" title="使用openssl加密"></a>使用openssl加密</h4><figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">openssl <span class="keyword">enc</span> -aes-256-cbc -<span class="keyword">e</span> -<span class="keyword">in</span> &#123;path-<span class="keyword">in</span>&#125; -<span class="keyword">out</span> &#123;path-<span class="keyword">out</span>&#125;  <span class="comment">//-e encrypt</span></div><div class="line">openssl <span class="keyword">enc</span> -aes-256-cbc -<span class="keyword">d</span> -<span class="keyword">in</span> &#123;path-<span class="keyword">in</span>&#125; -<span class="keyword">out</span> &#123;path-<span class="keyword">out</span>&#125;  <span class="comment">//-d decrypt</span></div></pre></td></tr></table></figure>
<h4 id="阻止休眠"><a href="#阻止休眠" class="headerlink" title="阻止休眠"></a>阻止休眠</h4><p><code>caffeinate</code>命令，不加参数就是无限时间，用control + C停止<br><code>caffeinate -i -t 3600</code>加参数以秒为单位。</p>
<h4 id="其他内容"><a href="#其他内容" class="headerlink" title="其他内容"></a>其他内容</h4><p>1.在<code>“简介”</code>中给文件添加<code>注释</code>可在spotlight搜索到。<br>2.<code>quick time player软件</code>可以录屏、录音、录屏幕！！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;花了一段时间积累的，不容易找到，也不容易发现的tricks。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>雅思课笔记</title>
    <link href="http://Rocklu.me/2016/01/29/%E9%9B%85%E6%80%9D%E8%AF%BE%E7%AC%94%E8%AE%B0/"/>
    <id>http://Rocklu.me/2016/01/29/雅思课笔记/</id>
    <published>2016-01-28T19:35:00.000Z</published>
    <updated>2016-06-06T08:41:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>华尔街英语雅思课程笔记。</p>
<h4 id="大作文"><a href="#大作文" class="headerlink" title="大作文"></a>大作文</h4><p>议论文，40min，250words（少字低分）</p>
<h5 id="高分Tips"><a href="#高分Tips" class="headerlink" title="高分Tips"></a>高分Tips</h5><ol>
<li>词汇和语法多样化（最多重复两次）</li>
<li>注意审题（别漏了<code>反面论证</code>、自己的观点）</li>
<li>注意用formal language。（名词化、被动、从句。）</li>
<li>论点后面增加支持句子，比如例子、论述。</li>
<li>多用逻辑连接词。重要！</li>
</ol>
<p><img src="http://7xrpbg.com1.z0.glb.clouddn.com/%E8%BF%9E%E6%8E%A5%E8%AF%8D.JPG" style="margin-top: 10px"></p>
<p style="margin-top:-30px; text-align: center; font-size:15px; font-weight: 500">连接词汇总</p>

<h5 id="推荐方法"><a href="#推荐方法" class="headerlink" title="推荐方法"></a>推荐方法</h5><ol>
<li>大框架：一段开头介绍，中间2-3段论证正反方面，最后一段总结观点。</li>
<li>用2min写一个<code>提纲</code>。头脑风暴，更具题目的倾向性分配正反两方面。（平衡局：1正/1反，正面局：2正/1反）</li>
<li>第一段书写指导：过去的背景(in the past)、现在的情况(these days)、别人意见、自己观点。</li>
<li>中间三段布局：正面局（两个优点各一段、一个缺点一段）平衡局（正面论述一段、反面论述一段）</li>
<li>中间段书写指导：一句<code>定义</code>观点，一句<code>解释</code>观点，一句<code>例子</code>，一句写写可能导致的<code>后果</code>及<code>重要性</code>。</li>
<li>最后总结段书写指导：就是把前面几段的main idea换种方式重复下…</li>
</ol>
<h5 id="PEE法"><a href="#PEE法" class="headerlink" title="PEE法"></a>PEE法</h5><p>point-&gt; explanation -&gt; example</p>
<h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><p>星期和月份必须大写</p>
<p>—</p>
<h4 id="口语"><a href="#口语" class="headerlink" title="口语"></a>口语</h4><p>口语测试总计20min。</p>
<ol>
<li>5个小问题，随便聊聊。</li>
<li>2min单独叙述，有1min纸笔准备。</li>
<li>3个深入问题，主要测试口语论证能力。</li>
</ol>
<h5 id="评价维度"><a href="#评价维度" class="headerlink" title="评价维度"></a>评价维度</h5><ol>
<li>Quantity - 说得越多越好，超时考官会打断你</li>
<li>Grammar - 小的语法错误别介意，尝试用复杂结构</li>
<li>Vocabulary - 多用副词，<code>视觉化</code>描述，<code>故事化</code>（used to…）</li>
<li>Organisation - 逻辑结构（basically、both、firstly）</li>
</ol>
<h5 id="高分Tips-1"><a href="#高分Tips-1" class="headerlink" title="高分Tips"></a>高分Tips</h5><ol>
<li>想的时候‘er….’是正常的，native speaker也会这样，但是想要以后就要一次说完一<code>整句</code>。</li>
<li>注意考虑回答的「完整性」，<code>正反</code>都要论述。</li>
</ol>
<h5 id="推荐替代「I-beg-your-pardon」？"><a href="#推荐替代「I-beg-your-pardon」？" class="headerlink" title="推荐替代「I beg your pardon」？"></a>推荐替代「I beg your pardon」？</h5><p>Would you mind repeating the question for me please?</p>
<h5 id="说不下去了咋办？"><a href="#说不下去了咋办？" class="headerlink" title="说不下去了咋办？"></a>说不下去了咋办？</h5><ol>
<li>转移话题，link to the area you good at</li>
<li>吹牛，被发现也没事</li>
<li>说你的父母朋友这种熟悉的人</li>
</ol>
<hr>
<h4 id="小作文"><a href="#小作文" class="headerlink" title="小作文"></a>小作文</h4><p>描述图、表、流程图。20min，150words。</p>
<h5 id="推荐方法-1"><a href="#推荐方法-1" class="headerlink" title="推荐方法"></a>推荐方法</h5><p>一段介绍（3句），两段主体（各4句），一段结论（3句）</p>
<ol>
<li>介绍段。1句背景介绍，换种方式描述下图表(paraphrasing题目)。<code>2个主要趋势</code>，各一句, 趋势要描述出来。（次段忌题详细数据）</li>
<li>主体段。分别讲第一段提到的两个大趋势的<code>细节</code>。（描述细节：最值、比较、增长最快…）</li>
<li>总结。把上面两段换种说法复述一遍。</li>
</ol>
<h5 id="高分Tips-2"><a href="#高分Tips-2" class="headerlink" title="高分Tips"></a>高分Tips</h5><ol>
<li>make a plan。计划下写哪俩趋势，用哪些数据支撑。</li>
<li>多花点时间看懂图表。意思理解偏差直接低分。</li>
<li>write <code>facts</code>, no opinions!</li>
<li>不要直接写数字（figure），加工一下。<ul>
<li>19%==just under a fifth</li>
<li>20%==one in five</li>
<li>25%==a quarter</li>
<li>51%==approximately half</li>
</ul>
</li>
</ol>
<h5 id="Paraphrasing建议"><a href="#Paraphrasing建议" class="headerlink" title="Paraphrasing建议"></a>Paraphrasing建议</h5><ul>
<li>graph = line graph / bar chart</li>
<li>diagram = figure</li>
<li>shows = illustrates / compares</li>
<li>proportion = percentage</li>
<li>from 1999 to 2009 = between 1999 to 2009 / over a period of 10 years</li>
<li>how to produce = the process of producing</li>
<li>in three countries = in the UK, France and Spain</li>
</ul>
<h5 id="重要表达"><a href="#重要表达" class="headerlink" title="重要表达"></a>重要表达</h5><p><code>下降</code>==decrease, drop, go down, fall, plummet, plunge<br><code>上升</code>==grow, rise, go up, roar, surge<br><code>波动</code>==fluctuate<br><code>稳定</code>==remain stable<br><code>达到最高点</code>==peak at<br><code>达到最低点</code>==bottom out<br><code>主要变化</code>==major change</p>
<p><code>副词汇总</code>==slightly, sharply, steadily, considerably, gradually, significantly,  relatively, dramatically<br><code>关于XX</code>==with regards to xx<br><code>相对于XX</code>==compared to XX<br><code>相当于</code>==amount to<br><code>由于</code>==stem from</p>
<p><code>增长3倍</code>==3 times bigger==increased by 300%==tripled in size</p>
<h5 id="范例句子"><a href="#范例句子" class="headerlink" title="范例句子"></a>范例句子</h5><p><strong>第一句描述图表</strong></p>
<ul>
<li>The two charts illustrate how much time male and female Australians spend on activities around the house.</li>
<li>This bar chart illustrate the percentage of people who spend time on different mobile phone activities each week in 2001 compared to 2013.</li>
<li>The line graph illustrate the amount of three lands of spreads(margarine, low fat and reduced spreads and butter) which were consumed over 26 years from 1981 to 2007. <strong>Units are measured in grams.</strong></li>
</ul>
<p><strong>第二句大趋势</strong></p>
<ul>
<li>The data suggests that Australian men and women prefer to do different tasks around the home, with women spending more time on most household activities than men.</li>
<li>Overall, the consumption of margarine and butter decreased over period given while for low fat and reduced spreads, it rose.</li>
</ul>
<p><strong>中间细节描述</strong></p>
<ul>
<li>At the start of the period, butter was the most popular spread, which was replaced by margarine from 1991 to 2001, and following that low fat and reduced spreads became the most widely used spread in the final years.</li>
<li>With regards to the amount of butter used, it began at around 140 grams and then peaked at 160 grams in 1986 before falling dramatically to about 50 grams in the last year.</li>
<li>Likewise, approximately 90 grams of margarine was eaten in the first year after which the figure fluctuated slightly and dropped to a low of 40 grams in 2007.</li>
<li>In 2001, approximately 35% of people spent time on social networking compared to 50% in 2013.</li>
</ul>
<hr>
<h4 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h4><p>60min，3篇文章，40道题。/是非题、选择题、填空总结题、连线题</p>
<h5 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h5><ol>
<li>读题要仔细！限定词</li>
<li>题量大，时间控制非常重要</li>
</ol>
<h5 id="推荐方法-2"><a href="#推荐方法-2" class="headerlink" title="推荐方法"></a>推荐方法</h5><ol>
<li>skimming（快速浏览一下文章，重点读首尾段、每段首尾。同时注意标注<code>路标</code>，如：日期、人名地名、事件等，方面scaning）</li>
<li>看下文章是否有「时间顺序」（chronological）</li>
<li>scanning（通过读题，快速定位答案的位置）</li>
<li>只有少量的位置仔细读。</li>
</ol>
<hr>
<h4 id="听力"><a href="#听力" class="headerlink" title="听力"></a>听力</h4><ol>
<li>注意重音词，通常是出题点。</li>
<li>注意语调。<br>「个人认为均无实际作用」</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;华尔街英语雅思课程笔记。&lt;/p&gt;
&lt;h4 id=&quot;大作文&quot;&gt;&lt;a href=&quot;#大作文&quot; class=&quot;headerlink&quot; title=&quot;大作文&quot;&gt;&lt;/a&gt;大作文&lt;/h4&gt;&lt;p&gt;议论文，40min，250words（少字低分）&lt;/p&gt;
&lt;h5 id=&quot;高分Tips&quot;&gt;&lt;
    
    </summary>
    
      <category term="english" scheme="http://Rocklu.me/categories/english/"/>
    
    
  </entry>
  
  <entry>
    <title>C++的本质</title>
    <link href="http://Rocklu.me/2015/12/22/C++%E7%9A%84%E6%9C%AC%E8%B4%A8/"/>
    <id>http://Rocklu.me/2015/12/22/C++的本质/</id>
    <published>2015-12-21T16:00:00.000Z</published>
    <updated>2016-03-29T09:36:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>此笔记为C++之父2014年的讲座『the essence of C++』。讲了cpp的本质以及近年来cpp11及14的改进。</p>
<a id="more"></a>
<h4 id="CPP的设计用途"><a href="#CPP的设计用途" class="headerlink" title="CPP的设计用途"></a>CPP的设计用途</h4><ul>
<li>系统编程</li>
<li>嵌入式系统</li>
<li>资源限制的系统</li>
</ul>
<h4 id="CPP的抽象层级"><a href="#CPP的抽象层级" class="headerlink" title="CPP的抽象层级"></a>CPP的抽象层级</h4><p>「轻量级」抽象的编程语言，希望用最小的代价实现抽象。</p>
<hr>
<h4 id="关于「资源管理」"><a href="#关于「资源管理」" class="headerlink" title="关于「资源管理」"></a>关于「资源管理」</h4><p>任何资源（包括内存、文件、socket、锁、线程等）都应该使用一个<code>handle</code>来管理。</p>
<h5 id="什么是handle？"><a href="#什么是handle？" class="headerlink" title="什么是handle？"></a>什么是handle？</h5><blockquote>
<p>A resource should be owned by a “handle”<br>A “handle” should present a well-defined and useful abstraction<br>E.g. a vector, string, file, thread</p>
</blockquote>
<p>handle就是一个代理，由handle去持有资源、管理资源。外界持有handle就可以了。<br>这样做主要是为了贯彻<code>RAII</code>的资源管理方式（Resource Acquisition Is Initialization），即「资源的handle在<code>初始化</code>时持有这个资源，在<code>析构</code>时释放资源」</p>
<h5 id="为啥需要handle？"><a href="#为啥需要handle？" class="headerlink" title="为啥需要handle？"></a>为啥需要handle？</h5><p>直接持有资源会容易在特殊情况下难以「释放」。例如：<br>1.中途抛出异常<br>2.中途退出函数<br>3.多线程间共享资源</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">2</span>);</div><div class="line"><span class="comment">//其他代码</span></div><div class="line">delet p;</div><div class="line"><span class="comment">//此时中间的代码如果抛异常，则内存泄露</span></div><div class="line"></div><div class="line"><span class="comment">//好的写法</span></div><div class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">2</span>));</div></pre></td></tr></table></figure>
<h5 id="CPP标准库中设计好的handle"><a href="#CPP标准库中设计好的handle" class="headerlink" title="CPP标准库中设计好的handle"></a>CPP标准库中设计好的handle</h5><ul>
<li>STL中的vector、list、thread等</li>
<li><code>shared_ptr</code>(引用计数)、<code>unique_ptr</code>(不带引用计数)</li>
<li>….</li>
</ul>
<h5 id="那什么时候用裸的指针？"><a href="#那什么时候用裸的指针？" class="headerlink" title="那什么时候用裸的指针？"></a>那什么时候用<code>裸的指针</code>？</h5><p>仅在handle的内部。<br>「注」裸的数组也是不推荐使用的，容易被攻击，且没有越界检查。</p>
<hr>
<h4 id="一个困扰的问题：如何从函数中传出大量数据？"><a href="#一个困扰的问题：如何从函数中传出大量数据？" class="headerlink" title="一个困扰的问题：如何从函数中传出大量数据？"></a>一个困扰的问题：如何从函数中传出大量数据？</h4><p>对于「工厂函数」或者其他要创造出新变量的函数，都需要在函数结束后返回一大堆<code>新的</code>数据。处理方式主要有以下几种：</p>
<ul>
<li>返回函数的局部变量（错误方法，堆内存在函数执行后被销毁）</li>
<li>返回new出来地址的指针（有问题，谁有责任去释放这块内存？）</li>
<li>返回new出来地址的引用（问题更大，外面的哥们儿怎么释放它？）</li>
<li>预先准备好一个变量，作为「传出参数」（很丑，UNIX中常用）<br>在C++11，解决了这个问题。解决方式是：<code>移动构造函数</code>(move constructor)</li>
</ul>
<h5 id="啥是「移动」？"><a href="#啥是「移动」？" class="headerlink" title="啥是「移动」？"></a>啥是「移动」？</h5><p>从设计初衷的角度看，首先避免<code>拷贝一份然后把原来的销毁</code>这种消耗资源的方式。其次对于传递指针地址的方式，主要问题也是出在「资源管理」。所以对于这样的资源如果用handle，只需要把handle持有的资源转移过去。这样copy的只是handle，代价小。</p>
<h5 id="所以移动的「前提」你要是一个handle。"><a href="#所以移动的「前提」你要是一个handle。" class="headerlink" title="所以移动的「前提」你要是一个handle。"></a>所以移动的「前提」你要是一个handle。</h5><hr>
<h4 id="关于垃圾回收"><a href="#关于垃圾回收" class="headerlink" title="关于垃圾回收"></a>关于垃圾回收</h4><p>垃圾回收的问题主要如下：</p>
<ol>
<li>不可预测</li>
<li>性能开销</li>
<li>只管理内存，不管理其他资源（锁、线程等）<br>「注」：C++11开始也支持垃圾回收了。STL</li>
</ol>
<hr>
<h4 id="关于泛型"><a href="#关于泛型" class="headerlink" title="关于泛型"></a>关于泛型</h4><ul>
<li>是一种廉价的（non-overhead）元编程</li>
<li>CPP14给泛型增加了类似于<code>协议</code>或者<code>接口</code>的功能</li>
<li>改善了泛型的错误提示</li>
</ul>
<hr>
<p>最后，附上链接：<a href="https://www.youtube.com/watch?v=86xWVb4XIyE" target="_blank" rel="external">https://www.youtube.com/watch?v=86xWVb4XIyE</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;此笔记为C++之父2014年的讲座『the essence of C++』。讲了cpp的本质以及近年来cpp11及14的改进。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>牛顿迭代法</title>
    <link href="http://Rocklu.me/2015/12/02/%E7%89%9B%E9%A1%BF%E8%BF%AD%E4%BB%A3%E6%B3%95/"/>
    <id>http://Rocklu.me/2015/12/02/牛顿迭代法/</id>
    <published>2015-12-02T15:38:00.000Z</published>
    <updated>2016-03-29T09:36:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>牛顿迭代法求平方根，一直知其然不知其所以然。为啥这个公式算出来能逼近？为啥逼近的就是根？今天认真学了一下，总算有点直观认知。</p>
<a id="more"></a>
<h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><p>求方程根的近似解。</p>
<h4 id="直观解释"><a href="#直观解释" class="headerlink" title="直观解释"></a>直观解释</h4><ol>
<li>首先，我们想要求的是「函数与x轴的交点」。</li>
<li>好，根据泰勒展开理论，「函数的切线」是「函数」的近似，于是<code>「切线与x轴的交点」</code>是「函数与x轴交点」的一个近似。也就是说这个切线的交点（新x），会更接近函数与x轴的交点。</li>
<li>每次迭代，就是在该点去计算「切线与x轴交点」得到一个新的近似值的过程。</li>
</ol>
<h4 id="理论证明"><a href="#理论证明" class="headerlink" title="理论证明"></a>理论证明</h4><p>根据泰勒展开式，y = f(x0)+f’(x0)(x-x0)+<code>o(x)</code><br>而在x0处的切线为：y = f(x0)+f’(x0)(x-x0)<br>这两式说明切线与函数本身<code>在小范围内的差别</code>是一个高阶无穷小。于是我们去掉后面的无穷小，用切线替代原来的函数，得到它的根，就是与x轴的交点：</p>
<blockquote>
<p>x = x0-f(x0)/f’(x0)</p>
</blockquote>
<p>这就是牛顿迭代法的「迭代公式」。<br>[注]泰勒展开的几何意义为函数的分解，理论上所有项加起来以后就是原来函数。</p>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>能化解为「方程根」问题的情况，比如求「极值」，转化为「导函数」的根。</p>
<h4 id="方法失效"><a href="#方法失效" class="headerlink" title="方法失效"></a>方法失效</h4><p>不能有<code>「重根」</code>。<br>重根的情况就是「函数与x轴相切」，相切出导数趋近于0。可以直观得看出牛顿法在这种情况并不收敛。</p>
<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>选一个更好的「初始值」会有利于更快得到比较接近的结果。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;牛顿迭代法求平方根，一直知其然不知其所以然。为啥这个公式算出来能逼近？为啥逼近的就是根？今天认真学了一下，总算有点直观认知。&lt;/p&gt;
    
    </summary>
    
      <category term="theory" scheme="http://Rocklu.me/categories/theory/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS毛玻璃效果</title>
    <link href="http://Rocklu.me/2015/11/10/iOS%E6%AF%9B%E7%8E%BB%E7%92%83%E6%95%88%E6%9E%9C/"/>
    <id>http://Rocklu.me/2015/11/10/iOS毛玻璃效果/</id>
    <published>2015-11-10T10:40:00.000Z</published>
    <updated>2016-03-29T09:36:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>自从iOS8，apple官方开放了「毛玻璃」特效的API，用起来有点奇怪。</p>
<a id="more"></a>
<p>方法如下：</p>
<ol>
<li>要使用UIView的子类<code>UIVisualEffectView</code></li>
<li>这个view的<code>backgroundColor</code>必须是<code>clearColor</code>，否则无效</li>
<li>这个view的subView都会被模糊，如果只想背景模糊，其他部件需要与之平级，不要添加为它的subView！</li>
<li>所以需要一个容器view用来存放这个view和其他部件，这个容器也应该是clearColor，注意alpha不要小于1，否则所有子view都会受影响。</li>
<li>设置这个view的<code>effect</code>属性，值为：<code>[UIBlurEffect effectWithStyle:UIBlurEffectStyleLight]</code>。注意有light，dark，extraLight三种可选。</li>
<li>如果觉得默认的太透明了，想要一点<code>白底</code>，请不要改变上述的颜色。正确做法是在毛玻璃特效的后面（平级）加入一个半透明的view（alpha0.3），这个view的颜色设置为乳白色或者灰色会有不错的效果。</li>
</ol>
<p>[注意]带有毛玻璃特效的view最好不要参与动画，特效在动画中不会被渲染，只有停下来才有效果。如果有动画会一下次出现背景比较突兀。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自从iOS8，apple官方开放了「毛玻璃」特效的API，用起来有点奇怪。&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://Rocklu.me/categories/IOS/"/>
    
    
  </entry>
  
  <entry>
    <title>App服务端搭建</title>
    <link href="http://Rocklu.me/2015/10/22/app%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%90%AD%E5%BB%BA/"/>
    <id>http://Rocklu.me/2015/10/22/app服务端搭建/</id>
    <published>2015-10-22T10:25:00.000Z</published>
    <updated>2016-03-29T09:36:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>搭建一个简单的app后端其实并没有太大的技术含量，但是这个过程中还是遇到一些坑的。</p>
<a id="more"></a>
<h4 id="服务器的连接"><a href="#服务器的连接" class="headerlink" title="服务器的连接"></a>服务器的连接</h4><p>对于云端的服务器来说，首先遇到的问题是：代码虽然可以远程用vim写，长期看来总需要传文件，怎么方便？<br>答：<code>scp</code>命令。[注]批量传输可用通配符，但是需要加转义斜杠.</p>
<p>例子：<br><code>scp root@120.27.54.111:/var/www/\*.php ~/Desktop</code><br><code>scp statistic.php root@120.27.54.111:/var/www/</code></p>
<p>另外，对于在线编辑代码的延迟，有什么解决方案嘛？<br>答：<code>mosh</code>开源shell，可以在本地进行预判响应。</p>
<h4 id="服务编写"><a href="#服务编写" class="headerlink" title="服务编写"></a>服务编写</h4><p>补充两个原来不清楚的知识：<br>1.对于app服务器，80端口需要让出来给网页，apache服务器怎么更换监听端口？<br>答：配置文件夹里找到<code>「ports.conf」</code>，里面有一句<code>listen 80</code>，我相信你懂了。然后记得重启apache。</p>
<p>2.想要定期运行脚本清理数据库怎么实现？<br>答：<code>crontab</code>命令。<code>-e</code>编辑，<code>-l</code>就是list，<code>-r</code>删除。</p>
<p>3.PHP的本地调试<br>好吧，我是最近才知道php可以本地执行的，<code>php PHP_filePath</code>就能运行了，直接echo在命令行里。</p>
<p>4.关于状态码「<code>重要</code>」<br>可能是由于约定俗称的原因，服务端返回的状态码基本与HTTP协议一致，AFNetwording网络库就规定只有200-299的状态码才算“成功”。<br>对于HTTP状态码，引用一个最近看到的cheatsheet，非常形象：<br>1xx, hold on （等一下，正在处理）<br>2xx, here you go!  （ok，正确）<br>3xx, go away  （跳转至其他页面）<br>4xx, you fucked up  （请求错误，如404页面不存在）<br>5xx, I fucked up  （服务器错误，如502 bad gateway）</p>
<h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p>1.本地缓存，就是写磁盘文件。<br>2.radis内存缓存。</p>
<h4 id="其他注意事项"><a href="#其他注意事项" class="headerlink" title="其他注意事项"></a>其他注意事项</h4><p>为了防止app端挂掉，尽量在服务端出错时也给予响应。</p>
<p>进一步参考：<br><a href="http://www.cnblogs.com/shangdahao/archive/2013/06/01/3111755.html" target="_blank" rel="external">http://www.cnblogs.com/shangdahao/archive/2013/06/01/3111755.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;搭建一个简单的app后端其实并没有太大的技术含量，但是这个过程中还是遇到一些坑的。&lt;/p&gt;
    
    </summary>
    
      <category term="TOOLS" scheme="http://Rocklu.me/categories/TOOLS/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS9更新后的坑</title>
    <link href="http://Rocklu.me/2015/10/14/iOS9%E6%9B%B4%E6%96%B0%E5%90%8E%E7%9A%84%E5%9D%91/"/>
    <id>http://Rocklu.me/2015/10/14/iOS9更新后的坑/</id>
    <published>2015-10-14T03:34:00.000Z</published>
    <updated>2016-03-29T09:36:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>iOS9出现以后，不但swift出了2.0版本，项目中也有很多其他地方做了更改。</p>
<a id="more"></a>
<h4 id="Bitcode"><a href="#Bitcode" class="headerlink" title="Bitcode"></a>Bitcode</h4><p>Bitcode is an intermediate representation of a compiled program. Apps you upload to iTunes Connect that contain bitcode will be compiled and linked on the App Store. Including bitcode will allow Apple to re-optimize your app binary in the future without the need to submit a new version of your app to the store.</p>
<p>Note: For iOS apps, bitcode is the default, but optional. If you provide bitcode, all apps and frameworks in the app bundle need to include bitcode. For watchOS apps, bitcode is required</p>
<p>简而言之就是用来支持增量更新的，默认开启，开启后可能会给包含C++库的项目造成无法编译的问题。</p>
<p><strong><code>如何关闭？</code></strong><br>项目配置-〉build option里面</p>
<h4 id="app中的HTTP请求被禁了"><a href="#app中的HTTP请求被禁了" class="headerlink" title="app中的HTTP请求被禁了"></a>app中的HTTP请求被禁了</h4><p>错误信息有：<code>App Transport Security</code>这样的，主要是因为apple建议使用<code>HTTPS</code>而不是<code>HTTP</code>。</p>
<p><strong><code>如何解决？</code></strong><br>在项目的<code>plist</code>文件中，新建「字典」<code>NSAppTransportSecurity</code>，在这个字典中，新建「布尔值」项目<code>NSAllowsArbitraryLoads</code>，并将其设置为<code>YES</code>。OK。</p>
<hr>
<p>下面是一些其他的坑。</p>
<h4 id="启动图片比你想象得要重要"><a href="#启动图片比你想象得要重要" class="headerlink" title="启动图片比你想象得要重要"></a>启动图片比你想象得要重要</h4><p>iOS7闪退因为启动图片不对，app打开后画面不能撑满屏幕因为启动图片在项目中设置得不对。这种诡异的bug浪费了我大量的时间。</p>
<h4 id="签名证书的问题"><a href="#签名证书的问题" class="headerlink" title="签名证书的问题"></a>签名证书的问题</h4><p>怪事1: ad-hoc分发给测试人员闪退，且在本机使用真实手机调试（手机连在电脑上测试）说进程丢失。而直接在手机中跑却ok。<br>原因：在building setting里面不是有设置code signing嘛，develop就用develop的证书，release就用release的证书。我本来全都用release的，查了stack overflow才知道这还有讲究。</p>
<p>怪事2: 在开发者中心注册、并且下载了最新的证书，在export安装包签名的时候却仍旧默认用老的证书。<br>原因：这是xcode的bug，默认就是使用列表里面的第一个，需要手动把老的证书删除，注意要在xcode里面删除，在文件夹里面删除没用的。</p>
<h4 id="关于Swift与OC混合编程"><a href="#关于Swift与OC混合编程" class="headerlink" title="关于Swift与OC混合编程"></a>关于Swift与OC混合编程</h4><p>实际测试下来，混合编程后在iOS7会发生无缘无故的bug导致闪退。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;iOS9出现以后，不但swift出了2.0版本，项目中也有很多其他地方做了更改。&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://Rocklu.me/categories/IOS/"/>
    
    
  </entry>
  
  <entry>
    <title>Unity3d使用SqLite的坑</title>
    <link href="http://Rocklu.me/2015/09/23/Unity3d%E4%BD%BF%E7%94%A8SqLite%E7%9A%84%E5%9D%91/"/>
    <id>http://Rocklu.me/2015/09/23/Unity3d使用SqLite的坑/</id>
    <published>2015-09-22T22:19:00.000Z</published>
    <updated>2016-03-29T09:37:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>SqLite作为轻量级C语言本地数据库，一直是挺讨我喜欢。这次实验室的Unity项目需要本地数据库，就研究了下怎么在Unity3D中集成sqlite。想不到坑那么多，各种坑，也是醉了。</p>
<a id="more"></a>
<p>步骤如下：</p>
<ol>
<li>Create new folder under Assets Folder Rename it <code>Plugins</code>.</li>
<li>Copy <code>sqlite3.def</code> and sqlite3.dll into <code>Assets/Plugins</code> in your unity project .You can download these files here <code>http://www.sqlite.org/download.html</code> for windows (Precompiled Binaries for Windows)</li>
<li>Download SQLite Browser <code>https://github.com/sqlitebrowser/sqlitebrowser</code>（GUI数据库编辑器）</li>
<li>Create Database in <code>Assets</code> folder in your unity project using SQLite Browser.（必须先手动创建好）</li>
<li>Copy <code>System.Data.dll</code> and <code>Mono.Data.Sqlite.dll</code> from <code>C:\Program Files (x86)\Unity \Editor\Data\Mono\lib\mono\2.0*</code> and paste them in your <code>Assets/Plugins*</code> folder in your unity project.</li>
<li>Add these namespaces <code>using Mono.Data.Sqlite; using System.Data; using System;</code></li>
</ol>
<p>然后，可以写一个helper类，unity里面可以自动引用。核心代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">string dbName =  &quot;/testDatabase.db&quot;;   //注意这里很容易出错，小心别漏了/号</div><div class="line">string tableName = &quot;testTable&quot;;</div><div class="line"></div><div class="line">//开始建立连接</div><div class="line">string conn = &quot;URI=file:&quot; + Application.dataPath + dbName; //Path to database.         IDbConnection dbconn;</div><div class="line">dbconn = (IDbConnection)new SqliteConnection(conn);</div><div class="line">dbconn.Open(); //Open connection to the database.</div><div class="line"></div><div class="line">//准备查询语句</div><div class="line">IDbCommand dbcmd = dbconn.CreateCommand();</div><div class="line">string sqlQuery = &quot;SELECT * FROM &quot; + tableName;</div><div class="line">dbcmd.CommandText = sqlQuery;</div><div class="line">//执行语句</div><div class="line">IDataReader reader = dbcmd.ExecuteReader();</div><div class="line"></div><div class="line"></div><div class="line">//下面开始处理返回数据</div><div class="line">while (reader.Read())</div><div class="line">&#123;</div><div class="line">    int ID = reader.GetInt32(0);      //返回一个数组，下标0则第一个字段</div><div class="line">    string text = reader.GetString(1) + &apos;\n&apos;;   //第二个字段</div><div class="line">    Debug.Log(&quot;ID= &quot; + ID + &quot;  name =&quot; + name);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//下面开始关闭连接</div><div class="line">reader.Close();</div><div class="line">reader = null;</div><div class="line">dbcmd.Dispose();</div><div class="line">dbcmd = null;</div><div class="line">dbconn.Close();</div><div class="line">dbconn = null;</div></pre></td></tr></table></figure>
<h5 id="坑在哪里？"><a href="#坑在哪里？" class="headerlink" title="坑在哪里？"></a>坑在哪里？</h5><p>这样子在编辑器里面就OK了，可是！不能编译。。。醉了，查了一下，需要调整Unity项目的设置，如下：<br><code>PlayerSetting -&gt; Other Settings -&gt; Optimization -&gt; Api Compatibility Level</code>这个下拉菜单，手动选择为：<code>.NET 2.0</code>。<br>于是我们终于可以编译了。</p>
<h5 id="别高兴太早，编译好之后的程序访问不了数据库。。。。"><a href="#别高兴太早，编译好之后的程序访问不了数据库。。。。" class="headerlink" title="别高兴太早，编译好之后的程序访问不了数据库。。。。"></a>别高兴太早，编译好之后的程序访问不了数据库。。。。</h5><p>经过长时间的反复排查，最后打印了db的路径，终于发现。。。编译的时候没有把数据库复制过去。。。需要<code>手动</code>把数据库复制到各个平台的运行文件中。<br>具体路径可打印<code>Application.dataPath</code>获得。</p>
<p>真不容易。。。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SqLite作为轻量级C语言本地数据库，一直是挺讨我喜欢。这次实验室的Unity项目需要本地数据库，就研究了下怎么在Unity3D中集成sqlite。想不到坑那么多，各种坑，也是醉了。&lt;/p&gt;
    
    </summary>
    
      <category term="TOOLS" scheme="http://Rocklu.me/categories/TOOLS/"/>
    
    
  </entry>
  
  <entry>
    <title>读《现代操作系统》</title>
    <link href="http://Rocklu.me/2015/09/09/%E8%AF%BB%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <id>http://Rocklu.me/2015/09/09/读现代操作系统/</id>
    <published>2015-09-09T07:26:00.000Z</published>
    <updated>2016-03-29T09:37:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>考研的时候操作系统是学得最好的一门课，看这本书主要是拾遗补缺。</p>
<a id="more"></a>
<h4 id="操作系统的功能："><a href="#操作系统的功能：" class="headerlink" title="操作系统的功能："></a>操作系统的功能：</h4><ol>
<li>硬件抽象（文件）</li>
<li>资源管理</li>
</ol>
<h4 id="进程和线程若干细节"><a href="#进程和线程若干细节" class="headerlink" title="进程和线程若干细节"></a>进程和线程若干细节</h4><ol>
<li>每个进程在自己的虚拟地址空间中，拥有独立的堆栈。</li>
<li>fork是UNIX系统中唯一能创建新进程的system call。</li>
<li>创建一个进程的速度，比创建一个线程慢1-2个数量级</li>
<li>对于「<code>内核级线程</code>」系统内核空间中，保存了「进程表」（包含pcb）和「线程表」（包含每个线程的寄存器）。对于「<code>用户级线程</code>」，则有进程自己管理线程表。</li>
<li>「重要的事情再强调一遍」：进程是资源调度的单位，线程是CPU调度的单位。</li>
<li>system call的时候，调度器没有执行，仍然是当前进程在工作。只是进入内核态以后，该进程有另外的堆栈及pc计数器（<code>内核上下文</code>），拥有高权限。这个内核上下文是用来应对内核态时遇到的时间片轮转以及阻塞后的恢复，同样存放在pcb中。</li>
</ol>
<h4 id="Linux的进程内存地址空间细节"><a href="#Linux的进程内存地址空间细节" class="headerlink" title="Linux的进程内存地址空间细节"></a>Linux的进程内存地址空间细节</h4><ol>
<li>32位机器上，linux虚拟地址空间位4GB，1GB给操作系统，其他给进程。这1GB只有在内核态时可被访问。「注意」windows应该是2GB</li>
<li>内核的1GB，在<code>虚拟地址空间</code>中是<code>高地址</code>（顶部），然而映射到<code>物理内存</code>中是最<code>低地址</code>。</li>
<li>进程的3GB虚拟空间中，最底下是<code>代码段</code>，从0地址开始。接着往上是<code>已经初始化的全局变量</code>，操作系统并不区分这两者。再往上是<code>未初始化的全局变量</code>（历史上叫BSS，原因不明），可以<code>向上</code>动态增长，也就是传说中的<code>heap堆</code>。中间空白，然后到最顶上，贴着3GB的顶，是<code>stack栈</code>，每次调用函数，<code>向下</code>分配一块固定的大小。（所以，在函数定义时，栈大小必须是确定的。这是导致数组不能动态指定大小的原因。）</li>
</ol>
<h4 id="文件系统补充"><a href="#文件系统补充" class="headerlink" title="文件系统补充"></a>文件系统补充</h4><ol>
<li>FAT表要读到内存里，太大的硬盘会让这个表很大占用内存</li>
<li>inode统一放在磁盘的一片区域，然后有一个bit-map记录inode是否已用。（读入内存）</li>
<li>Linux的文件系统叫ext2</li>
</ol>
<h4 id="日志文件系统（LFS）"><a href="#日志文件系统（LFS）" class="headerlink" title="日志文件系统（LFS）"></a>日志文件系统（LFS）</h4><ol>
<li>为什么要日志？：磁盘操作分多步骤（写目录，写inode，写文件），中间如果遇到故障就导致文件丢失。</li>
<li>怎么办？：a)在做操作之前，在日志区域，写下将要做的操作。b)开始操作。c)操作完成后删除刚刚写的日志。</li>
<li>有什么用呢？：于是如果中途出问题，就会在日志区域留下日志，系统开机时，只要检查日志区域如果有东西，就把那个日志再完整执行一遍即可。</li>
<li>有什么overhead嘛？：有，所有的操作必须保证重复执行不会有副作用。（因为可能执行了几步断掉，然后重启后再执行一遍。）（这叫<code>幂等操作</code>）</li>
</ol>
<h4 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h4><ol>
<li>加密过程<code>‘盐’</code>的作用？：主要担心对于已知加密算法的<code>预计算</code>，黑客可以根据预计算的串与加密后的密码比对，从而得到密码。加盐可以让预计算失效。相当于个性化定制加密算法。</li>
<li><code>一次性口令</code>。「功能」：不怕网络流量嗅探，不怕服务器存储密码的文件被窃取。「步骤」：a)与服务器约定加密算法f，和加密次数n。b)首次登录时，用户给服务器的是<code>对原始密码用f加密n次的串</code>，服务器存储这个值。c)第二次登录时，给服务器发送<code>对原始密码用f加密的n-1次的串</code>，服务器只要把这个新串用f加密一次，与上一个密码比对一致即通过。d)当n被减到0时，重新来一次这样的设定。n的大小一般比较大。e)这样搞以后，就算黑客获取到本次的密码，但是无法计算出下一次的密码。「要求」：加密算法比较简单，应该算是一种简单的哈希，同时要求哈希完毕的产出长度与输入一致。这俩要求都是因为要迭代n次。另外的要求是不可逆。</li>
</ol>
<h4 id="windows中的注册表"><a href="#windows中的注册表" class="headerlink" title="windows中的注册表"></a>windows中的注册表</h4><p>实质是统一集中管理的配置文件集合，在开机时载入内存。注册表让<code>热插拔</code>成为可能。（书中并没有解释为什么，待科普）</p>
<hr>
<h3 id="附录：考研时期操作系统笔记精选"><a href="#附录：考研时期操作系统笔记精选" class="headerlink" title="附录：考研时期操作系统笔记精选"></a>附录：考研时期操作系统笔记精选</h3><hr>
<h4 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h4><p>进程是操作系统管理运行中程序的一种抽象，由PCB进程管理。process control block。PCB存放在系统「内核空间」中，主要内容包含：<br>1) 资源清单（打开的文件等）<br>2) 进程的控制信息（代码段在虚地址空间的地址、<code>页表</code>、根目录等）<br>3) CPU上下文 （寄存器值、堆栈指针）<br>4) 内核态CPU上下文</p>
<h4 id="进程调度的几个思想"><a href="#进程调度的几个思想" class="headerlink" title="进程调度的几个思想"></a>进程调度的几个思想</h4><p>a）优先级：优先处理响应时间要求较短的任务。（多级队列）<br>b）抢占：高优先级任务到来时，暂停正在处理的低优先级任务，先处理高的。<br>c）时间片轮转：各个进程轮流运行一段时间，保证响应时间有<code>上限</code>。<br>d）反馈：时间片如果不够用，则说明你<code>目前</code>是CPU繁忙，那下次就给你更长的时间片，更低的优先级。反之，如果用不完你就自己block了，则说明你目前是IO繁忙，下次给你短时间片，更高优先级。</p>
<p>「为什么一般优先处理IO繁忙进程？」：为了让IO和CPU资源有效并发工作。</p>
<h4 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h4><ol>
<li>同步互斥（信号量）</li>
<li>管道</li>
<li>共享内存</li>
<li>进程间消息</li>
</ol>
<p>「什么是<code>临界区</code>」：访问共享资源的一段<code>代码</code>。<br>「PV操作解决竟态问题的关键在哪里？」：1.原语不可被打断（捆绑了加锁和访问计数器的操作）。2.等待时自动阻塞，释放CPU。</p>
<hr>
<h4 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h4><p>_</p>
<h5 id="内存分页"><a href="#内存分页" class="headerlink" title="内存分页"></a>内存分页</h5><p>「目的」：解决内存分配的<code>碎片</code>问题。分页后碎片平均为页面大小的50%。<br>「为啥页面的大小一般是2的幂次？」：方便通过内存地址计算页面号。<br>「为啥要有页表？」：实现虚地址和物理地址的映射。<br>「为啥要有快表TLB？」：<code>页表存放在内存里</code>（PCB中），所以每次访问一个内存地址，实际上要读两次内存，这是无法忍受的。TLB是一个硬件，相当于页表的Cache。<br>「为啥要有多级页表？」：虚地址空间好大，于是页表好大。然而那么多的地址空间，对于单个进程来说，大多数是空的。多级页表可以只把用到的页表加载到PCB中，控制页表的大小。当然也会增加页表的访问次数。另外，多级页表中，项目的数量应当也是2的幂次，方便根据地址高位查找。</p>
<h5 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h5><p>「理论基础」：程序的局部性原理。<br>「什么是Belady现象？」：分配给进程的物理页面增加时，它的缺页率反而提高的现象。<br>「影响缺页率的因素」：1）页面替换算法。2）配给的页面数。3）编程方式。<br>「页面分配策略」：a）固定分配：配给进程的物理页面数量恒定。b）可变分配：缺页率较低的进程可以让出物理页面给需要的进程。</p>
<h5 id="内存分段"><a href="#内存分段" class="headerlink" title="内存分段"></a>内存分段</h5><p>「目的」：程序实际上是有结构的，如代码段、堆栈等。按照进程的结构区分内存区块，有利于动态加载以及共享。<br>「段页式内存分配」：先分段，段内再分页。先查段表，再查页表。</p>
<hr>
<h4 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h4><p>_</p>
<h5 id="存放方式"><a href="#存放方式" class="headerlink" title="存放方式"></a>存放方式</h5><p>a）链表存放—FAT表，一种<code>静态链表</code>。知道首块地址就能依次查找到最后。<br>b）索引存放—iNode节点。所有块的地址都写在这个node里。<br>「为何要有二级索引？」iNode大小有限（磁盘区块大小），于是存储的索引项目有限，需要用二级索引扩容。</p>
<h5 id="空闲区块管理"><a href="#空闲区块管理" class="headerlink" title="空闲区块管理"></a>空闲区块管理</h5><p>a）bit-map<br>b）把所有空闲块号组成一个链表</p>
<h5 id="二进制打开文件和ASCII打开文件的区别？"><a href="#二进制打开文件和ASCII打开文件的区别？" class="headerlink" title="二进制打开文件和ASCII打开文件的区别？"></a>二进制打开文件和ASCII打开文件的区别？</h5><p>ASCII打开时会去辨认<code>换行符</code>（Win是<code>\r\n</code>，Linux是<code>\n</code>，Mac是<code>\r</code>），可以<code>按行读取</code>。二进制打开则只能按字节读取，速度比较快。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;考研的时候操作系统是学得最好的一门课，看这本书主要是拾遗补缺。&lt;/p&gt;
    
    </summary>
    
      <category term="basic theory" scheme="http://Rocklu.me/categories/basic-theory/"/>
    
    
  </entry>
  
  <entry>
    <title>关于git的push方式</title>
    <link href="http://Rocklu.me/2015/08/25/git%E7%9A%84push%E6%96%B9%E5%BC%8F/"/>
    <id>http://Rocklu.me/2015/08/25/git的push方式/</id>
    <published>2015-08-25T01:17:00.000Z</published>
    <updated>2016-03-29T09:38:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>装完cocopods以后，突然发现push到github的时候每次都要输入用户名和密码，烦得不行。查了一下，是push的方式被改成<code>https</code>了，原来是<code>ssh</code>。</p>
<a id="more"></a>
<p>在terminal里面输入：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">git remote -v</div><div class="line">得到结果：</div><div class="line">origin <span class="attribute">https</span>:<span class="comment">//github.com/yuquan0821/demo.git (fetch)</span></div><div class="line">origin <span class="attribute">https</span>:<span class="comment">//github.com/yuquan0821/demo.git (push)</span></div><div class="line">看到里面的https了吗？</div><div class="line"></div><div class="line"></div><div class="line">下面的命令把push方式改成ssh：</div><div class="line">git remote rm origin</div><div class="line">git remote add origin git<span class="variable">@github</span>.<span class="attribute">com</span>:yuquan0821/demo.git</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;装完cocopods以后，突然发现push到github的时候每次都要输入用户名和密码，烦得不行。查了一下，是push的方式被改成&lt;code&gt;https&lt;/code&gt;了，原来是&lt;code&gt;ssh&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="TOOLs" scheme="http://Rocklu.me/categories/TOOLs/"/>
    
    
  </entry>
  
  <entry>
    <title>ipa重签名</title>
    <link href="http://Rocklu.me/2015/08/23/ipa%E9%87%8D%E7%AD%BE%E5%90%8D/"/>
    <id>http://Rocklu.me/2015/08/23/ipa重签名/</id>
    <published>2015-08-22T19:05:00.000Z</published>
    <updated>2016-03-29T09:38:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>缘由是朋友问我淘宝上买的「双开微信」是不是安全，我就去研究了下bundle改签名的原理。本来以为不就是改个签名嘛，想不到坑很大。</p>
<a id="more"></a>
<h4 id="方法一：手动用codesign命令："><a href="#方法一：手动用codesign命令：" class="headerlink" title="方法一：手动用codesign命令："></a>方法一：手动用<code>codesign</code>命令：</h4><p>这条命令是mac电脑默认自带的，格式如下：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">codesign -fs <span class="string">"iPhone Distribution: Le Lu (99ZNA7BG5M)"</span> --entitlements ~<span class="regexp">/Desktop/</span>entitlements.plist ~<span class="regexp">/.../</span>Pastebot1.<span class="number">4.2</span><span class="regexp">/Payload/</span>Pastebot.app</div></pre></td></tr></table></figure>
<p>这条命令可以覆盖原来的签名。</p>
<p>「注意1」<br><code>iPhone Distribution: Le Lu (99ZNA7BG5M)</code>是证书的名字，可在钥匙串工具里面找到证书，然后看里面的<code>commom name</code>栏目<br>「注意2」<br>这里需要自己制作一个plist文件，命名为<code>entitlements.plist</code>，文本如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></div><div class="line"><span class="meta">&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">plist</span> <span class="attr">version</span>=<span class="string">"1.0"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">key</span>&gt;</span>application-identifier<span class="tag">&lt;/<span class="name">key</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">string</span>&gt;</span>SXY7J8MS3P.me.rocklule.test<span class="tag">&lt;/<span class="name">string</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">key</span>&gt;</span>com.apple.developer.team-identifier<span class="tag">&lt;/<span class="name">key</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">string</span>&gt;</span>SXY7J8MS3P<span class="tag">&lt;/<span class="name">string</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">key</span>&gt;</span>get-task-allow<span class="tag">&lt;/<span class="name">key</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">false</span>/&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">key</span>&gt;</span>keychain-access-groups<span class="tag">&lt;/<span class="name">key</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">array</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">string</span>&gt;</span>SXY7J8MS3P.me.rocklule.test<span class="tag">&lt;/<span class="name">string</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">array</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">plist</span>&gt;</span></div></pre></td></tr></table></figure>
<p>其中：<code>SXY7J8MS3P.me.rocklule.test</code>是需要改动的，前面的<code>SXY7J8MS3P</code>是开发者前缀，可以在钥匙串工具里的证书说明里面查到，后面是包名，注意所有这本的包名要一致。<br>「坑1」：这个文件前面不可以有空格，有了就不行。<br>「坑2」：网上这个文件版本有两种，另一种不好使。。。</p>
<p>第二步是把<code>xx.mobileprovision</code>改名为<code>embedded.mobileprovision</code>放到app目录下。<br>「坑1」名字不可改。<br>「坑2」这个文件有不同的发布版本，<code>必须</code>是<code>app store</code>方式。</p>
<p>完成后用zip命令打包：<br><code>zip -r xxxx.ipa SORCE_DIER</code></p>
<h4 id="方法二：用iReSign软件"><a href="#方法二：用iReSign软件" class="headerlink" title="方法二：用iReSign软件"></a>方法二：用<code>iReSign</code>软件</h4><p>这个软件在github有链接，直接下载下来用就可以。会自动帮你提取证书的commom name，比较方便。</p>
<h4 id="最大的坑"><a href="#最大的坑" class="headerlink" title="最大的坑"></a>最大的坑</h4><p>必须要<code>企业证书</code>重签名的app才能安装，个人证书签完了闪退。。。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;缘由是朋友问我淘宝上买的「双开微信」是不是安全，我就去研究了下bundle改签名的原理。本来以为不就是改个签名嘛，想不到坑很大。&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://Rocklu.me/categories/IOS/"/>
    
    
  </entry>
  
  <entry>
    <title>JS_CheatSheet</title>
    <link href="http://Rocklu.me/2015/07/09/JS_CheatSheet/"/>
    <id>http://Rocklu.me/2015/07/09/JS_CheatSheet/</id>
    <published>2015-07-08T22:01:00.000Z</published>
    <updated>2016-03-29T09:38:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>以下是犀牛书前几章的笔记。基本涵盖了js的主要语言特性，并没有包含高级特性。以后有需要再深入。</p>
<a id="more"></a>
<h4 id="小细节"><a href="#小细节" class="headerlink" title="小细节"></a>小细节</h4><ol>
<li>js 区分大小写，而html不区分</li>
<li>js中所有的数字都是IEEE754的<code>64位</code>浮点数。「注意」浮点数舍入。</li>
<li>数组下标是<code>32位</code>无符号整数。</li>
</ol>
<h4 id="未定义的变量"><a href="#未定义的变量" class="headerlink" title="未定义的变量"></a>未定义的变量</h4><p>未定义的变量看上去像全局变量，实际上不是，它被自动生成为全局对象的<code>属性</code>。</p>
<h4 id="对于字符"><a href="#对于字符" class="headerlink" title="对于字符"></a>对于字符</h4><p>采用<code>UTF-16</code>编码，通常每个字符用16bit表示，超出16bit的不分，则用32个bit表示。对字符变量取<code>.length</code>时，每16bit为1。即通常一个字符的长度为1，如果该字符超出UTF-16的范围，则长度为2。<br>「另外」js中可以采用<code>\u0008</code>这样的unicode编码直接表示某字符。</p>
<h4 id="包装对象"><a href="#包装对象" class="headerlink" title="包装对象"></a>包装对象</h4><p>对于<code>字符串</code>、<code>数字</code>、<code>布尔值</code>三种「原始类型」，在调用其属性或方法时，解释器会调用<code>String()</code>、<code>Number()</code>、<code>Boolean()</code>构造函数，生成一个「临时」的包装对象，然后用这个对象进行属性或方法调用。作用于这个临时对象的操作并不对原来那个值产生影响，需小心。</p>
<h4 id="偷懒的类型转化"><a href="#偷懒的类型转化" class="headerlink" title="偷懒的类型转化"></a>偷懒的类型转化</h4><p>x + ‘’     =》 转字符串<br>+x   =》 转数字<br>!!x   =》  转布尔值</p>
<h5 id="值得注意的类型转化"><a href="#值得注意的类型转化" class="headerlink" title="值得注意的类型转化"></a>值得注意的类型转化</h5><p>字符串转布尔：非空串即true<br>字符串转数字：有字母则NaN，空串为0<br>Object转布尔：恒为true<br>Object转数字：恒为NaN</p>
<h4 id="对象到原始值的转化"><a href="#对象到原始值的转化" class="headerlink" title="对象到原始值的转化"></a>对象到原始值的转化</h4><p><code>toSting()</code>转为sting，<code>valueOf()</code>转为number<br>「注」如果一个对象没有toString方法，或者这个方法无效（原封不动返回对象而不是原始值）。此时解释器会尝试调用valueOf方法，先转成数字，再转成字符串。对于valueOf也是这样，转不动的时候会去尝试调用toString。。。好无奈</p>
<h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>没有块级作用域，只有<code>函数作用域</code>。即在函数内无论何处定义都可用。<br>「变量名提前」，即在同一个作用域内，后面定义的变量前面就能用了。但注意提前的只是<code>声明</code>，初始化仍然是在后面。</p>
<h4 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h4><p>可以调用上一层函数作用域里面的对象。由链表一层一层向上找。</p>
<p>「具体实现」：作用域链是对象的链表，每个节点代表一个函数作用域。变量的作用域由函数的<code>定义</code>位置决定，但是只有在在函数<code>执行</code>时，才会开始拓展作用域链。具体步骤是：创建一个对象，包含这个函数内定义的所有局部变量，然后把这个对象作为链表指向上一个节点（这是由函数的定义位置决定的）。</p>
<p>再谈「闭包」：</p>
<ol>
<li>我们为什么要用闭包？希望解决的问题是：再次调用函数时，希望能从上一次的状态继续。或者说，希望保存函数的<code>状态</code>。于是有了方法1:全局变量。缺点：乱，不好维护。于是有了方法2：把状态变量直接挂载到函数上，作为一个属性（函数也是对象）。缺点：缺乏私有的访问限制。于是我们终于有了方法3：闭包。所以闭包解决的问题，只不过是让这个状态变量私有化。<code>松本行弘</code>认为，闭包与Class都是把函数与变量封装起来，他们的关系就像一个硬币的正反面，只是实现方式不同罢了。</li>
<li>机理。js与c不同，函数的调用并不在<code>栈空间</code>，而是创建一个<code>临时对象</code>存放局部变量。如果没有其他变量引用这个对象，在函数执行完毕后该对象会被垃圾回收。而闭包就是把局部定义的函数返回出去，让外界引用持有，于是整个函数生成的临时对象都会存活下来。</li>
<li>要注意的有两点：1：由于每次函数执行都会生成一个临时对象，所以那些临时变量间互不干扰，分别处于同级别的<code>不同的</code>作用域链。2：要时刻注意闭包虽然把变量封闭在函数里面了，但是这些变量并没有固化静态快照。</li>
<li>现在看来，闭包在功能是为了封装隔离某些函数多次调用时需要保存的状态变量。其实在class机制完全的语言里，只要把那些变量设为private就可以实现，只是js的类机制比较弱，用作用域链实现隔离。</li>
</ol>
<h4 id="属性访问表达式"><a href="#属性访问表达式" class="headerlink" title="属性访问表达式"></a>属性访问表达式</h4><p>要访问一个对象的属性，可以是点语法，也可以在方括号里面写属性的名称字符串。<br>「注意」方括号里面无论是什么，先转字符串！所以即使是数组下标，也是先把数字转成字符串去查找的。</p>
<h4 id="「相等」的判定"><a href="#「相等」的判定" class="headerlink" title="「相等」的判定"></a>「相等」的判定</h4><ol>
<li><code>==</code>允许类型转化，<code>===</code>不允许类型转化</li>
<li>对象的比较，比较的是指针。</li>
<li>字符串的比较，比较的是unicode码，码不同，即使字符相同也不等</li>
<li><code>NaN</code>与任何值都不相等，它和自己也不等。</li>
<li>数字与其他类型比较均转化为数字再比较</li>
</ol>
<h4 id="eval-函数"><a href="#eval-函数" class="headerlink" title="eval()函数"></a>eval()函数</h4><p>eval函数把参数字符串作为代码来执行，并可调用eval位置的上下文。<br>如果给eval函数取别名，调用别名函数时，则操作全局上下文（局部变量不可见）</p>
<h4 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h4><p>switch的行为类似于c语言。「注意」case的判定不做类型转化，即<code>===</code>。</p>
<h4 id="JS的对象"><a href="#JS的对象" class="headerlink" title="JS的对象"></a>JS的对象</h4><p>js的<code>对象</code>就是<code>「字典」</code>。<br>js的继承是对象的继承，而不是class的继承。<br>对象的「prototype」就是<code>构造函数</code>的<code>prototype</code>属性<br>对象的「class」就是「构造函数」<code>（有待验证）</code></p>
<p>「例子」一个数组[1, 2]，Array就是它的类，<code>Array.prototype</code>就是它的原型。对于数组的各种方法均定义在Array.prototype中。</p>
<h4 id="属性的特性（property-attribute）"><a href="#属性的特性（property-attribute）" class="headerlink" title="属性的特性（property attribute）"></a>属性的特性（property attribute）</h4><ol>
<li><code>writable</code>—可写。（可修改）</li>
<li><code>enumerable</code>—可枚举。</li>
<li><code>configurable</code>—可配置。（就是能否更改这些属性）</li>
</ol>
<h4 id="属性的检测"><a href="#属性的检测" class="headerlink" title="属性的检测"></a>属性的检测</h4><ol>
<li><code>x.hasOwnProperty()</code>—检测自有属性</li>
<li><code>in</code>运算符—-检测包括继承的属性</li>
<li><code>x.propertyIsEnumerable()</code>—检测可枚举的<code>自有</code>属性<br>「啥叫可枚举」用for-in遍历对象时，会遍历到的属性就是enumerable的</li>
</ol>
<h4 id="delete运算符"><a href="#delete运算符" class="headerlink" title="delete运算符"></a>delete运算符</h4><p>删除对象对属性的<code>引用</code>。通常可以删除某个属性，但是如果其子属性也被其他对象引用，并不会被立刻销毁。<br>另外，delete不能销毁继承来的属性。</p>
<p><code>Object.Keys()</code>与<code>Object.getOwnPropertyNames()</code>的区别？<br>第一个会追溯原型链，第二个不会。</p>
<h4 id="关于「数组」值得注意的地方"><a href="#关于「数组」值得注意的地方" class="headerlink" title="关于「数组」值得注意的地方"></a>关于「数组」值得注意的地方</h4><ol>
<li>直接量的语法中，最后一个逗号<code>,</code>是可以选的。[,]是空数组</li>
<li>数组的索引是32位整数。</li>
<li>数组与普通对象的区别？维护一个length，索引为<code>unsigned_int32_t</code></li>
<li>「省略值」仍旧有key，而value是<code>undefined</code>。这不代表没有元素。</li>
<li>for-in不会遍历到省略值的key。</li>
</ol>
<h4 id="关于「函数」值得注意的地方"><a href="#关于「函数」值得注意的地方" class="headerlink" title="关于「函数」值得注意的地方"></a>关于「函数」值得注意的地方</h4><ol>
<li>调用函数时，解释器并不检查传入的参数。</li>
<li>函数也是<code>对象</code>，可以有属性，存点状态什么的。</li>
</ol>
<h4 id="函数的「arguments」属性"><a href="#函数的「arguments」属性" class="headerlink" title="函数的「arguments」属性"></a>函数的「arguments」属性</h4><ol>
<li>它是一个<code>类数组</code>（行为看上去像数组），下标访问得到实际传入的参数</li>
<li><code>arguments.length</code>代表传入的<code>实参</code>数量，<code>arguments.callee.length</code>代表函数定义时的<code>形参</code>数量。</li>
<li><code>callee</code>属性代表当前函数</li>
<li><code>caller</code>属性代表调用本函数的函数</li>
<li>「注意」callee和caller在<code>严格模式</code>下不可用。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以下是犀牛书前几章的笔记。基本涵盖了js的主要语言特性，并没有包含高级特性。以后有需要再深入。&lt;/p&gt;
    
    </summary>
    
      <category term="JS" scheme="http://Rocklu.me/categories/JS/"/>
    
    
  </entry>
  
  <entry>
    <title>IOS开发笔记</title>
    <link href="http://Rocklu.me/2015/05/27/IOS%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    <id>http://Rocklu.me/2015/05/27/IOS开发笔记/</id>
    <published>2015-05-27T08:01:00.000Z</published>
    <updated>2016-03-29T09:38:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>IOS开发已经搞了两个月，积累了一些经验。详实记录，以供查阅。</p>
<a id="more"></a>
<h4 id="调用OC的代码"><a href="#调用OC的代码" class="headerlink" title="调用OC的代码"></a>调用OC的代码</h4><ol>
<li>需要建立一个<code>bridging-header.h</code>（本来好像会自动建立，现在需要手动建立了，名字无所谓）</li>
<li>在项目的<code>Build Settings</code>里面搜索swift，可以看到<code>Swift Compiler - Code Generation</code>大栏目，里面有<code>Objective-C Bridging Header</code>，把刚刚建立的头文件名字放进去就ok</li>
<li>然后，所有的oc头文件只要包含在这个桥文件里面，就自动在所有的swift文件里面可以使用了。</li>
</ol>
<hr>
<h4 id="如何创建一个View"><a href="#如何创建一个View" class="headerlink" title="如何创建一个View"></a>如何创建一个View</h4><p>总体来说，如果这个View只管展示，不需要交互，可以直接创建一个裸的UIView。否则就创建一个UIViewController，会自带一个View。</p>
<p><strong>方法一：通过storyBoard</strong></p>
<ol>
<li>有入口箭头的Controller会默认加载，如果找不到箭头了，请在controller属性里面找<code>Is Initial View Controller</code>把它勾上</li>
<li>对于segue指向的controller也是会自动加载</li>
<li>对于无法用segue连线的单独controller也可以放在storyboard中，此时先通过代码加载storyboard，然后通过唯一的<code>Storyboard ID</code>加载这个controller。<br>示例代码：<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> storyBoard = <span class="type">UIStoryboard</span>(name: <span class="string">"Main"</span>, bundle: <span class="literal">nil</span>)    <span class="comment">//先加载storyboard对象</span></div><div class="line"><span class="keyword">let</span> chat = storyBoard.instantiateViewControllerWithIdentifier(<span class="string">"inquiry"</span>) <span class="keyword">as</span>! <span class="type">InquiryChatTableViewController</span>    <span class="comment">//再加载controller</span></div></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>方法二：通过xib</strong><br>类似于从storyBoard，优点是多个view可以放在单独的文件里，归类。<br>示例代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> nib = <span class="type">UINib</span>(nibName: <span class="string">"TabBarView"</span>, bundle: <span class="literal">nil</span>)  <span class="comment">//记得设置xib控件里面的class</span></div><div class="line"><span class="keyword">let</span> newTabBar = nib.instantiateWithOwner(<span class="literal">nil</span>, options: <span class="literal">nil</span>)[<span class="number">0</span>] <span class="keyword">as</span>! <span class="type">MyTabBar</span>  <span class="comment">//注意实例化后返回的是数组</span></div></pre></td></tr></table></figure>
<p><strong>方法三：通过代码new</strong><br>我碰到大概有这几种情况需要自己new</p>
<ol>
<li>界面布局需要动态计算</li>
<li>需要一次性循环生成多个view</li>
<li>布局太简单没有什么子控件</li>
</ol>
<hr>
<h4 id="自定义控件的若干经验"><a href="#自定义控件的若干经验" class="headerlink" title="自定义控件的若干经验"></a>自定义控件的若干经验</h4><ol>
<li>基本思路是创建一个新类继承自默认类，然后对需要改动的方法进行override。</li>
<li>自定义的view如果需要交互，一般设置一个委托delegate属性，配套一个协议protocol定义好调用的函数，然后把外部的controller设置为它的委托，让view持有引用（weak）。事件发生时，view通过调用委托在协议中定义好的方法把事件传递给外部的controller。</li>
<li>自定义控件如果布局复杂，通常会搞一个xib，把控件的class设置为自定义的view。</li>
<li>从xib连线到view的<code>@IBOutlet</code>什么时候生效？ 这个需要详细查询view的生命周期，总之记住，在init()里面它们还为被设置，此时这些@IBOutlet的属性还均是nil。一个比较合适的方法是用swift的新功能<code>didSet</code>，在didset里面对这些属性进行配置。</li>
<li>对于需要用代码创建的子控件，可以放在init函数里面。此时处理事件就要<code>addTarget</code></li>
<li>如果你的控件看不见……检查下以下方面：1，frame，2，是否加入主view的subView，3，alpha</li>
<li>当控件的frame变化时，会调用<code>layoutSubviews</code>，所以在这里面设置subView的frame最合适。</li>
</ol>
<hr>
<h4 id="关于启动页图片"><a href="#关于启动页图片" class="headerlink" title="关于启动页图片"></a>关于启动页图片</h4><ol>
<li>图片命名为：<code>Default@2x.png</code>和<code>Default-568h@2x.png</code>放入项目</li>
<li>把[项目设置]中，<code>launch screen file</code>设置为<code>空</code>即可自动调用</li>
</ol>
<hr>
<h4 id="UIButton专题"><a href="#UIButton专题" class="headerlink" title="UIButton专题"></a>UIButton专题</h4><p>_</p>
<h5 id="各种属性设置"><a href="#各种属性设置" class="headerlink" title="各种属性设置"></a>各种属性设置</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> btn = <span class="type">UIButton</span>()</div><div class="line">btn.frame = <span class="type">CGRectMake</span>(<span class="number">12</span>, <span class="number">12</span>, <span class="number">12</span>, <span class="number">12</span>)</div><div class="line"><span class="keyword">self</span>.view.addSubview(btn)</div><div class="line"></div><div class="line"><span class="comment">//这些圆角的设定也适合于UIView</span></div><div class="line">btn.layer.cornerRadius = <span class="number">4</span></div><div class="line">btn.layer.borderColor = mixiColor.mainCoffie.<span class="type">CGColor</span></div><div class="line">btn.layer.borderWidth = <span class="number">0.5</span></div><div class="line">btn.layer.masksToBounds = <span class="literal">true</span>  <span class="comment">//如果里面的子view多出来，就切掉</span></div><div class="line"></div><div class="line"><span class="comment">//文字相关</span></div><div class="line">btn.setTitle(‘title', forState: <span class="type">UIControlState</span>.<span class="type">Normal</span>)</div><div class="line">btn.titleLabel?.font = <span class="type">UIFont</span>.systemFontOfSize(<span class="number">12</span>)</div><div class="line">btn.setTitleColor(mixiColor.mainCoffie, forState: <span class="type">UIControlState</span>.<span class="type">Normal</span>)</div><div class="line">btn.setTitleColor(mixiColor.mainCoffie, forState: <span class="type">UIControlState</span>.<span class="type">Highlighted</span>)</div><div class="line">btn.setTitleColor(<span class="type">UIColor</span>.whiteColor(), forState: <span class="type">UIControlState</span>.<span class="type">Selected</span>)</div><div class="line"></div><div class="line"><span class="comment">//背景颜色</span></div><div class="line">btn.setBackgroundImage(buttonImage, forState: <span class="type">UIControlState</span>.<span class="type">Selected</span>)</div><div class="line">btn.backgroundColor = mixiColor.mainCoffie</div><div class="line"></div><div class="line"><span class="comment">//事件</span></div><div class="line">btn.addTarget(<span class="keyword">self</span>, action:<span class="type">Selector</span>(<span class="string">"distrectBtnPressed:"</span>), forControlEvents: <span class="type">UIControlEvents</span>.<span class="type">TouchUpInside</span>)</div></pre></td></tr></table></figure>
<h5 id="按钮中图片和文字的位置怎么调？"><a href="#按钮中图片和文字的位置怎么调？" class="headerlink" title="按钮中图片和文字的位置怎么调？"></a>按钮中图片和文字的位置怎么调？</h5><p>调整对齐方式：属性-&gt;Control-&gt;Alignment<br>调整padding：属性-&gt;Button栏最下面-&gt;Edge选文字还是图片-&gt;Inset<br>想图片在上文字在下：重写layoutSubviews方法。</p>
<h5 id="如何让按钮按下去的时候不变色"><a href="#如何让按钮按下去的时候不变色" class="headerlink" title="如何让按钮按下去的时候不变色"></a>如何让按钮按下去的时候不变色</h5><p><code>btn.adjustsImageWhenHighlighted = false</code></p>
<h5 id="如何让按钮不能点"><a href="#如何让按钮不能点" class="headerlink" title="如何让按钮不能点"></a>如何让按钮不能点</h5><p><code>btn.userInterractionEnabled = false</code></p>
<hr>
<h4 id="素材图片的拉伸"><a href="#素材图片的拉伸" class="headerlink" title="素材图片的拉伸"></a>素材图片的拉伸</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIImage</span></span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">resizabelImage</span>(#<span class="title">name</span> :<span class="title">String</span>) -&gt;<span class="title">UIImage</span>?</span>&#123;</div><div class="line">        <span class="keyword">if</span> <span class="keyword">let</span> normalImage = <span class="type">UIImage</span>(named: name)&#123;</div><div class="line">            <span class="keyword">let</span> w = <span class="type">CGFloat</span>(normalImage.size.width * <span class="number">0.5</span>)</div><div class="line">            <span class="keyword">let</span> h = <span class="type">CGFloat</span>(normalImage.size.width * <span class="number">0.5</span>)</div><div class="line">            <span class="keyword">return</span> normalImage.resizableImageWithCapInsets(<span class="type">UIEdgeInsets</span>(top: h, <span class="keyword">left</span>: w, bottom: h, <span class="keyword">right</span>: w))</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h4 id="控制键盘"><a href="#控制键盘" class="headerlink" title="控制键盘"></a>控制键盘</h4><p>_</p>
<h5 id="关闭键盘"><a href="#关闭键盘" class="headerlink" title="关闭键盘"></a>关闭键盘</h5><p><code>self.view.endEditing(true)</code></p>
<h5 id="触摸任意区域关闭键盘"><a href="#触摸任意区域关闭键盘" class="headerlink" title="触摸任意区域关闭键盘"></a>触摸任意区域关闭键盘</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> tapGestureRecognizer:<span class="type">UITapGestureRecognizer</span> = <span class="type">UITapGestureRecognizer</span>(target: <span class="keyword">self</span>, action: <span class="string">"keyboardHide"</span>)</div><div class="line"></div><div class="line"><span class="comment">//为啥要加下面这行？答：不加的话里面的view的按钮会点不动。</span></div><div class="line"><span class="comment">//参考：http://blog.csdn.net/kylinbl/article/details/9139473</span></div><div class="line">tapGestureRecognizer.cancelsTouchesInView = <span class="literal">false</span>;</div><div class="line"><span class="keyword">self</span>.view.addGestureRecognizer(tapGestureRecognizer)</div></pre></td></tr></table></figure>
<h5 id="监听键盘弹出事件"><a href="#监听键盘弹出事件" class="headerlink" title="监听键盘弹出事件"></a>监听键盘弹出事件</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//这里是viewDidLoad里面</span></div><div class="line"><span class="type">NSNotificationCenter</span>.defaultCenter().addObserver(<span class="keyword">self</span>, selector: <span class="type">Selector</span>(<span class="string">"keyboardWillChangeFrame"</span>), name: <span class="string">"UIKeyboardWillChangeFrameNotification"</span>, object: <span class="literal">nil</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//这里是controller的class里面</span></div><div class="line"><span class="comment">//弹出键盘时同时向上滚动view</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">keyboardWillChangeFrame</span><span class="params">(note :NSNotification)</span></span>&#123;</div><div class="line">    <span class="keyword">var</span> shift :<span class="type">CGFloat</span> = <span class="number">0</span></div><div class="line">    <span class="keyword">let</span> userInfo = note.userInfo!</div><div class="line">    <span class="keyword">let</span> keyboardFrame = userInfo[<span class="type">UIKeyboardFrameEndUserInfoKey</span>]?.<span class="type">CGRectValue</span>()</div><div class="line">    <span class="keyword">let</span> transformY = keyboardFrame!.origin.y - <span class="keyword">self</span>.view.frame.size.height</div><div class="line">    <span class="keyword">let</span> duration = userInfo[<span class="type">UIKeyboardAnimationDurationUserInfoKey</span>] <span class="keyword">as</span>! <span class="type">Double</span></div><div class="line">    <span class="type">UIView</span>.animateWithDuration(duration, animations: &#123;</div><div class="line">        <span class="keyword">self</span>.view.transform = <span class="type">CGAffineTransformMakeTranslation</span>(<span class="number">0</span>, transformY + shift)</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//这里是controller的class里面</span></div><div class="line"><span class="comment">//记得给controller写deinit，移除消息通知监听(必须)</span></div><div class="line"><span class="keyword">deinit</span> &#123;</div><div class="line">    <span class="type">NSNotificationCenter</span>.defaultCenter().removeObserver(<span class="keyword">self</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="呼出键盘"><a href="#呼出键盘" class="headerlink" title="呼出键盘"></a>呼出键盘</h5><p><code>textField对象.becomeFirstResponder()</code></p>
<hr>
<h4 id="界面跳转"><a href="#界面跳转" class="headerlink" title="界面跳转"></a>界面跳转</h4><p>在segue的prepare中不要直接去更新目标页面控件，而是把数据传给它的module，因为此时outlet还没有设置。然后在viewdidload中，用更新好的module来设置UI。</p>
<p>往回跳<br>self.navigationController?.popToRootViewControllerAnimated(true)<br>self.navigationController?.popViewControllerAnimated(true)</p>
<p>数据怎么回传？<br>前面那个controller成为后面那个的代理（搞个协议），让后面那个持有前面那个的指针，然后就可以传参数调用前面那个controller的函数了</p>
<hr>
<h4 id="UITabbarController的自定义经验"><a href="#UITabbarController的自定义经验" class="headerlink" title="UITabbarController的自定义经验"></a>UITabbarController的自定义经验</h4><ol>
<li>重写viewWillAppear()，在里面直接self.tabBar.removeFromSuperview()。</li>
<li>把自定义的tabBar放到原来tabBar的位置（直接copy它的frame）</li>
<li>对于点击事件，UITabbarController作为自定义tabbar的委托，调用<code>self.selectedIndex = 下标数字</code>即可切换子controller</li>
<li>添加子controller的方法：<code>self.addChildViewController(子controller)</code></li>
</ol>
<hr>
<h4 id="UINavigationController的配置经验"><a href="#UINavigationController的配置经验" class="headerlink" title="UINavigationController的配置经验"></a>UINavigationController的配置经验</h4><p>这个导航条蛮搞的，UINavigationController不但提供view的容器，还提供bar的容器。</p>
<h5 id="哪些是由UINavigationController管的"><a href="#哪些是由UINavigationController管的" class="headerlink" title="哪些是由UINavigationController管的"></a>哪些是由UINavigationController管的</h5><p>主要是格式类的配置，大概是希望一次性设置不用每个子controller再设置</p>
<ol>
<li>bar的<code>背景染色</code>(navi.navigationBar.<code>barTintColor</code>)</li>
<li>bar上title的<code>文字属性</code>titleTextAttributes。包括颜色、字体、阴影等。</li>
<li>bar上的<code>item染色</code>tintColor</li>
<li>bar的特性，比如<code>navi.hidesBarsOnSwipe = true</code>，向上滑动时自动收起bar</li>
</ol>
<h5 id="哪些是由子controller管的配置"><a href="#哪些是由子controller管的配置" class="headerlink" title="哪些是由子controller管的配置"></a>哪些是由子controller管的配置</h5><p>内容性的配置，主要由一个navigationItem存储这些内容。（相当于一个module）</p>
<ol>
<li>左边和右边的barItem（self.navigationItem.leftBarButtonItem）</li>
<li>bar上面的title文字内容（self.navigationItem.title）<br>「注」<code>self.navigationController</code>得到的就是上面那个UINavigationController</li>
</ol>
<h5 id="如何干掉默认的返回键文字"><a href="#如何干掉默认的返回键文字" class="headerlink" title="如何干掉默认的返回键文字"></a>如何干掉默认的返回键文字</h5><p>左上角默认会把上一个controller的title写在那里，处理起来很不方便。有一个很机智的做法：重写上一个controller的<code>viewWillAppear</code>和<code>viewWillDisappear</code>，将要出现的时候加上title，将要消失的时候就把title设置为空。这样，push到下一个controller的时候返回键那里显示就是空拉~</p>
<h5 id="如何设置barItem的位置？"><a href="#如何设置barItem的位置？" class="headerlink" title="如何设置barItem的位置？"></a>如何设置barItem的位置？</h5><p><code>self.navigationItem.leftBarButtonItem?.imageInsets = UIEdgeInsets(...)</code></p>
<h5 id="如何截获controller的pop？"><a href="#如何截获controller的pop？" class="headerlink" title="如何截获controller的pop？"></a>如何截获controller的pop？</h5><p>重写<code>popViewControllerAnimated(...)</code>方法，可以在pop前自定义操作，甚至可以指定pop至的controller。</p>
<hr>
<h4 id="UITableViewController的配置经验"><a href="#UITableViewController的配置经验" class="headerlink" title="UITableViewController的配置经验"></a>UITableViewController的配置经验</h4><p>这个contorller强制你整个view都是tableview，不能加点别的东西，比较死，一般不用。通常是在一个默认的UIViewController里面拖一个tableView进去，设置一下delegation和dataSource。</p>
<h5 id="为什么看不到cell？"><a href="#为什么看不到cell？" class="headerlink" title="为什么看不到cell？"></a>为什么看不到cell？</h5><p>记得写这俩函数：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">numberOfSectionsInTableView</span><span class="params">(...)</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>            <span class="comment">//返回table的组数</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(..., numberOfRowsInSection ...)</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">10</span>           <span class="comment">//返回table的行数，告诉controller每组一共几行</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(..., cellForRowAtIndexPath ...)</span></span>&#123;</div><div class="line">    <span class="keyword">let</span> cell = tableView.dequeueReusableCellWithIdentifier(<span class="string">"DaRenCell"</span>, forIndexPath: indexPath) <span class="keyword">as</span>! <span class="type">DaRenTableViewCell</span>    <span class="comment">//DaRenCell是Prototype cell的id</span></div><div class="line">    <span class="keyword">return</span> cell         <span class="comment">//返回一个cell对象，告诉controller每一行显示啥</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="自动调整的row-height"><a href="#自动调整的row-height" class="headerlink" title="自动调整的row height"></a>自动调整的row height</h5><p>如果cell里面的控件全都使用autoLayout，则可以让系统自己自动调整行高。在controller中做一下配置即可：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">tableView.estimatedRowHeight = tableView.rowHeight</div><div class="line">tableView.rowHeight = <span class="type">UITableViewAutomaticDimension</span></div></pre></td></tr></table></figure></p>
<h5 id="数据重载"><a href="#数据重载" class="headerlink" title="数据重载"></a>数据重载</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//重载整个table</span></div><div class="line"><span class="keyword">self</span>.tableView.reloadData()</div><div class="line"><span class="comment">//重载单个cell并带动画</span></div><div class="line"><span class="keyword">self</span>.tableView.reloadRowsAtIndexPaths([<span class="type">NSIndexPath</span>(forRow: rowNmuber, inSection: <span class="number">0</span>)] , withRowAnimation: <span class="type">UITableViewRowAnimation</span>.<span class="type">Automatic</span>)</div></pre></td></tr></table></figure>
<h5 id="滚动到指定的位置"><a href="#滚动到指定的位置" class="headerlink" title="滚动到指定的位置"></a>滚动到指定的位置</h5><p>没仔细研究，总觉的这个方法有时有行有时候不行：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">self</span>.tableView.scrollToRowAtIndexPath(<span class="type">NSIndexPath</span>(forRow: <span class="keyword">self</span>.chatData.data.<span class="built_in">count</span>-<span class="number">1</span>, inSection: <span class="number">0</span>), atScrollPosition: <span class="type">UITableViewScrollPosition</span>.<span class="type">Bottom</span>, animated: <span class="literal">true</span>)</div></pre></td></tr></table></figure></p>
<h5 id="滚动的检测"><a href="#滚动的检测" class="headerlink" title="滚动的检测"></a>滚动的检测</h5><p>tableView继承自scrollView，所以会调用<code>scrollViewDidScroll()</code>方法</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//这段让上面的bar在tableview向上滚动时自动收起来</span></div><div class="line"><span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> mainSearchBar: <span class="type">UIView</span>!</div><div class="line"><span class="keyword">var</span> lastOffSet :<span class="type">CGFloat</span> = <span class="number">0</span></div><div class="line"><span class="keyword">var</span> accumulate :<span class="type">CGFloat</span> = <span class="number">0</span>  <span class="comment">//累计判断正负，以防变化太快</span></div><div class="line"></div><div class="line"><span class="comment">//监听tableview的滑动</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">scrollViewDidScroll</span><span class="params">(scrollView: UIScrollView)</span></span> &#123;</div><div class="line">    accumulate += scrollView.contentOffset.y - lastOffSet   <span class="comment">//累计混动的距离，向上增加，向下减少</span></div><div class="line">    <span class="keyword">if</span>(accumulate &gt; <span class="number">150</span>)&#123;           <span class="comment">//150的阈值比较合适</span></div><div class="line">        accumulate = <span class="number">0</span></div><div class="line">        <span class="comment">//这里代码让bar向上滑动，以隐藏</span></div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(accumulate &lt; -<span class="number">10</span>)&#123;      <span class="comment">//恢复的阈值设置的较低</span></div><div class="line">        accumulate = <span class="number">0</span></div><div class="line">        <span class="comment">//这里代码让bar恢复</span></div><div class="line">    &#125;</div><div class="line">    lastOffSet = scrollView.contentOffset.y</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h4 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h4><p>动画有两个比较常用，一个带结束后步骤，一个不带。<br>「注意」同一个线程里，虽然你可以不等前面那个结束就开始下一个动画，但并不会并发。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="type">UIView</span>.animateWithDuration(<span class="number">0.1</span>, animations: &#123;[<span class="keyword">unowned</span> <span class="keyword">self</span>] <span class="keyword">in</span></div><div class="line"><span class="keyword">self</span>.bookDateView.alpha = <span class="number">0</span>     <span class="comment">//满满变透明</span></div><div class="line">&#125;, completion: &#123;</div><div class="line"><span class="keyword">if</span> $<span class="number">0</span>&#123;      <span class="comment">//这个$0是匿名函数必须的，代表动画是否成功</span></div><div class="line"><span class="type">MBProgressHUD</span>.showHUDAddedTo(<span class="keyword">self</span>.view, animated: <span class="literal">true</span>)</div><div class="line">&#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">//这个简单版本不带completion</span></div><div class="line"><span class="type">UIView</span>.animateWithDuration(<span class="number">0.3</span>, animations: &#123;[<span class="keyword">unowned</span> <span class="keyword">self</span>] <span class="keyword">in</span></div><div class="line"><span class="keyword">self</span>.bookSucceedView.alpha = <span class="number">1</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">//注意这里[unowned self] 意思是闭包中不要捕获self，以防循环引用</span></div></pre></td></tr></table></figure></p>
<hr>
<h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><p>并没有深入研究，保存了一点有用的代码：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> qos = <span class="type">Int</span>( <span class="type">QOS_CLASS_USER_INTERACTIVE</span>.value)</div><div class="line"><span class="keyword">let</span> queue = dispatch_get_global_queue(qos, <span class="number">0</span>)</div><div class="line">dispatch_async(queue) &#123;</div><div class="line">    sleep(<span class="number">2</span>)</div><div class="line">    <span class="comment">//do something</span></div><div class="line">    dispatch_async(dispatch_get_main_queue()) &#123;   <span class="comment">//UI相关的动作必须切换到主线程</span></div><div class="line">        <span class="keyword">self</span>.tableView.reloadData()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<h4 id="折纸效果的侧滑栏实现"><a href="#折纸效果的侧滑栏实现" class="headerlink" title="折纸效果的侧滑栏实现"></a>折纸效果的侧滑栏实现</h4><p>滑动时侧边栏跟着移动并带渐变阴影，滑动时根据力度决定是否划开。<br>这段代码我记得写了整整一天，调了无数bug，做到了较好的体验。<br>并没有办法重现当时的神勇，直接保留代码。。。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//  SlideViewController.swift</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//  Created by LuRock on 15/3/22.</span></div><div class="line"><span class="comment">//  Copyright (c) 2015年 LuRock. All rights reserved.</span></div><div class="line"><span class="comment">//</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> UIKit</div><div class="line"></div><div class="line"><span class="comment">//侧滑栏的宽度比例</span></div><div class="line"><span class="keyword">let</span> <span class="type">SLIDERATE</span> :<span class="type">CGFloat</span> = <span class="number">0.6</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">leftBarButtunDelegate</span> :<span class="title">class</span></span>&#123;      <span class="comment">//class关键字可以让这个协议使用weak指针，原因待查</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">leftBarButtunClicked</span><span class="params">()</span></span></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SlideViewController</span>: <span class="title">UIViewController</span>, <span class="title">leftBarButtunDelegate</span>, <span class="title">SlideBarViewDelegate</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">var</span> slideBar :<span class="type">SlideBarViewController</span>!</div><div class="line"></div><div class="line">    <span class="comment">//存放所有可以被侧滑拦切换出来的viewcontroller。字典，key是view的名字，如“个人中心”</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">var</span> mainviewController = [<span class="type">String</span>:<span class="type">UIViewController</span>]()</div><div class="line">    <span class="comment">//标记活动的controller</span></div><div class="line">    <span class="keyword">var</span> activeMainViewControler :<span class="type">UIViewController</span>!</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">//用来记录侧滑手势的上一个偏移值</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">var</span> lastX :<span class="type">CGFloat</span> = <span class="number">0</span></div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">super</span>.viewDidLoad()</div><div class="line"></div><div class="line">        <span class="comment">//这里从storyboard读取并实例化侧边栏</span></div><div class="line">        <span class="keyword">let</span> storyboard = <span class="type">UIStoryboard</span>(name: <span class="string">"Main"</span>, bundle: <span class="literal">nil</span>)</div><div class="line">        <span class="keyword">self</span>.slideBar = storyboard.instantiateViewControllerWithIdentifier(<span class="string">"SlideBar"</span>) <span class="keyword">as</span>! <span class="type">SlideBarViewController</span></div><div class="line">        <span class="keyword">self</span>.slideBar.delegate = <span class="keyword">self</span></div><div class="line"></div><div class="line">        <span class="comment">//设置侧边栏的frame</span></div><div class="line">        <span class="keyword">self</span>.slideBar.view.frame = <span class="type">CGRect</span>(x: -<span class="keyword">self</span>.view.frame.width * <span class="type">SLIDERATE</span> * <span class="number">0.25</span>, y: <span class="number">0</span>, width: <span class="keyword">self</span>.view.frame.width * <span class="type">SLIDERATE</span>, height: <span class="keyword">self</span>.view.frame.height)</div><div class="line"></div><div class="line">        <span class="comment">//先加到数组里面的view会在下面</span></div><div class="line">        <span class="keyword">self</span>.addChildViewController(slideBar)</div><div class="line">        <span class="keyword">self</span>.view.addSubview(slideBar.view)</div><div class="line">        <span class="keyword">self</span>.view.sendSubviewToBack(slideBar.view)   <span class="comment">//这句可以把某个view弄到最底下</span></div><div class="line"></div><div class="line">        <span class="comment">//实例化子controller，设置它们的delegation，放置到mainviewController字典里</span></div><div class="line">        setUpMainViewController()</div><div class="line"></div><div class="line">    &#125;<span class="comment">//viewDidLoad</span></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">//这是个proxy，是为了统一化侧滑栏的阴影和移动</span></div><div class="line">    <span class="keyword">var</span> slideBarTransform :<span class="type">CGAffineTransform</span> = <span class="type">CGAffineTransformIdentity</span>&#123;</div><div class="line">        <span class="keyword">didSet</span>&#123;</div><div class="line">            <span class="keyword">self</span>.slideBar.view.transform = slideBarTransform</div><div class="line">            <span class="keyword">self</span>.slideBar.shadow.alpha = <span class="number">1</span> - slideBarTransform.tx / (<span class="keyword">self</span>.slideBar.view.frame.width * <span class="type">SLIDERATE</span> * <span class="number">0.5</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">//translation不是翻译的意思，意思是“移动量”</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">didDrag</span><span class="params">(pan:UIPanGestureRecognizer)</span></span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">let</span> point = pan.translationInView(pan.view!)</div><div class="line">        <span class="keyword">let</span> slideBarWidth = <span class="keyword">self</span>.slideBar.view.frame.width</div><div class="line">        <span class="keyword">let</span> duration = <span class="number">0.25</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">let</span> viewFrameMinX = pan.view?.frame.minX&#123;</div><div class="line">            <span class="keyword">if</span> (pan.state == <span class="type">UIGestureRecognizerState</span>.<span class="type">Changed</span>)&#123;</div><div class="line">                <span class="comment">//这里记录上次的位置，以确定拖拽方向</span></div><div class="line">                <span class="keyword">self</span>.lastX = viewFrameMinX</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 结束拖拽</span></div><div class="line">            <span class="keyword">if</span> (pan.state == <span class="type">UIGestureRecognizerState</span>.<span class="type">Cancelled</span> || pan.state == <span class="type">UIGestureRecognizerState</span>.<span class="type">Ended</span>) &#123;</div><div class="line">                <span class="keyword">if</span>(viewFrameMinX &gt; <span class="keyword">self</span>.lastX)&#123; <span class="comment">//如果向右拖</span></div><div class="line">                    <span class="keyword">if</span> (viewFrameMinX &gt;= slideBarWidth * <span class="number">0.2</span>) &#123; <span class="comment">// 往右边至少走动了五分之一</span></div><div class="line">                        <span class="type">UIView</span>.animateWithDuration(duration, animations: &#123;</div><div class="line">                            pan.view!.transform = <span class="type">CGAffineTransformMakeTranslation</span>(slideBarWidth, <span class="number">0</span>)</div><div class="line">                            <span class="keyword">self</span>.slideBarTransform = <span class="type">CGAffineTransformMakeTranslation</span>(slideBarWidth * <span class="type">SLIDERATE</span> * <span class="number">0.5</span>, <span class="number">0</span>)</div><div class="line"></div><div class="line">                        &#125;)</div><div class="line"></div><div class="line">                    &#125; <span class="keyword">else</span>&#123; <span class="comment">// 走动距离的没有达到四分之一</span></div><div class="line">                        <span class="type">UIView</span>.animateWithDuration(duration, animations: &#123;</div><div class="line">                            pan.view!.transform = <span class="type">CGAffineTransformIdentity</span>   <span class="comment">//这个参数需要理解，能复原位置</span></div><div class="line">                            <span class="keyword">self</span>.slideBarTransform = <span class="type">CGAffineTransformIdentity</span></div><div class="line"></div><div class="line">                        &#125;)</div><div class="line">                    &#125;</div><div class="line">                &#125;<span class="keyword">else</span>&#123;</div><div class="line">                    <span class="keyword">if</span> (viewFrameMinX &lt;= slideBarWidth * <span class="number">0.8</span>) &#123; <span class="comment">// 往左边至少走动了五分之一</span></div><div class="line">                        <span class="type">UIView</span>.animateWithDuration(duration, animations: &#123;</div><div class="line">                            pan.view!.transform = <span class="type">CGAffineTransformIdentity</span></div><div class="line">                            <span class="keyword">self</span>.slideBarTransform = <span class="type">CGAffineTransformIdentity</span></div><div class="line">                        &#125;)</div><div class="line"></div><div class="line">                    &#125; <span class="keyword">else</span>&#123;</div><div class="line">                        <span class="type">UIView</span>.animateWithDuration(duration, animations: &#123;</div><div class="line">                            pan.view!.transform = <span class="type">CGAffineTransformMakeTranslation</span>(slideBarWidth, <span class="number">0</span>)</div><div class="line">                            <span class="keyword">self</span>.slideBarTransform = <span class="type">CGAffineTransformMakeTranslation</span>(slideBarWidth * <span class="type">SLIDERATE</span> * <span class="number">0.5</span>, <span class="number">0</span>)</div><div class="line"></div><div class="line">                        &#125;)</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// begin和changed都会进来</span></div><div class="line">                pan.view!.transform = <span class="type">CGAffineTransformTranslate</span>(pan.view!.transform, point.x, <span class="number">0</span>)</div><div class="line">                slideBarTransform = <span class="type">CGAffineTransformTranslate</span>(<span class="keyword">self</span>.slideBar.view.transform, point.x * <span class="type">SLIDERATE</span> * <span class="number">0.5</span>, <span class="number">0</span>)</div><div class="line">                pan.setTranslation(<span class="type">CGPointZero</span>, inView: pan.view!)</div><div class="line">                <span class="keyword">if</span> (pan.view!.frame.minX &gt;= slideBarWidth) &#123;</div><div class="line">                    pan.view!.transform = <span class="type">CGAffineTransformMakeTranslation</span>(slideBarWidth, <span class="number">0</span>)</div><div class="line">                    slideBarTransform = <span class="type">CGAffineTransformMakeTranslation</span>(slideBarWidth * <span class="type">SLIDERATE</span> * <span class="number">0.5</span>, <span class="number">0</span>)</div><div class="line"></div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pan.view!.frame.minX &lt;= <span class="number">0</span>) &#123;</div><div class="line">                    pan.view!.transform = <span class="type">CGAffineTransformIdentity</span></div><div class="line">                    slideBarTransform = <span class="type">CGAffineTransformIdentity</span></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">//代理方法，监听左上角点击</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">leftBarButtunClicked</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">self</span>.view.endEditing(<span class="literal">true</span>)</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">self</span>.activeMainViewControler.view.frame.minX == <span class="number">0</span>)&#123;</div><div class="line">            <span class="type">UIView</span>.animateWithDuration(<span class="number">0.4</span>, animations: &#123;</div><div class="line">                <span class="keyword">self</span>.activeMainViewControler.view.transform = <span class="type">CGAffineTransformMakeTranslation</span>(<span class="keyword">self</span>.slideBar.view.frame.width, <span class="number">0</span>)</div><div class="line">                <span class="keyword">self</span>.slideBarTransform = <span class="type">CGAffineTransformMakeTranslation</span>(<span class="keyword">self</span>.slideBar.view.frame.width * <span class="type">SLIDERATE</span> * <span class="number">0.5</span>, <span class="number">0</span>)</div><div class="line"></div><div class="line">            &#125;)</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            <span class="type">UIView</span>.animateWithDuration(<span class="number">0.4</span>, animations: &#123;</div><div class="line">                <span class="keyword">self</span>.activeMainViewControler.view.transform = <span class="type">CGAffineTransformIdentity</span></div><div class="line">                <span class="keyword">self</span>.slideBarTransform = <span class="type">CGAffineTransformIdentity</span></div><div class="line">            &#125;)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//代理方法，监听左边bar的点击，切换主view</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">changeMainViewToTarget</span><span class="params">(targetView: String?)</span></span> &#123;</div><div class="line"></div><div class="line">        <span class="keyword">let</span> gesture = <span class="type">UIPanGestureRecognizer</span>(target: <span class="keyword">self</span>, action: <span class="type">Selector</span>(<span class="string">"didDrag:"</span>))</div><div class="line"></div><div class="line">        <span class="keyword">if</span> <span class="keyword">let</span> acticeView = <span class="keyword">self</span>.activeMainViewControler?.view&#123;   <span class="comment">//有旧view</span></div><div class="line"></div><div class="line">            <span class="comment">//如果点击已经活动的view，那就不要切换了</span></div><div class="line">            <span class="keyword">if</span> <span class="keyword">self</span>.activeMainViewControler! == mainviewController[targetView!]!&#123;</div><div class="line">                <span class="keyword">return</span></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            leftBarButtunClicked()</div><div class="line"></div><div class="line">            <span class="comment">//记录目前view的位置，等下交给新view</span></div><div class="line">            <span class="comment">//          let originTransform = acticeView.frame   //如果这里用frame，则后面手势计算transform的时候会有严重bug</span></div><div class="line">            <span class="keyword">let</span> originTransform = acticeView.transform</div><div class="line"></div><div class="line">            <span class="type">UIView</span>.animateWithDuration(<span class="number">0.4</span>, animations: &#123; [<span class="keyword">unowned</span> <span class="keyword">self</span>] <span class="keyword">in</span></div><div class="line">                acticeView.transform = <span class="type">CGAffineTransformMakeTranslation</span>(<span class="keyword">self</span>.view.frame.width, <span class="number">0</span>)</div><div class="line">                &#125;, completion: &#123;</div><div class="line">                    <span class="keyword">if</span> $<span class="number">0</span>&#123;</div><div class="line">                        <span class="comment">//重要问题：手势识别器不能同时被多个view注册，否则只认最后一个view的手势</span></div><div class="line">                        <span class="comment">//解除手势</span></div><div class="line">                        acticeView.removeGestureRecognizer(gesture)</div><div class="line">                        <span class="comment">//去除view</span></div><div class="line">                        acticeView.removeFromSuperview()</div><div class="line">                    &#125;</div><div class="line">            &#125;)</div><div class="line">            <span class="comment">//这里开始加新view</span></div><div class="line">            <span class="keyword">if</span> <span class="keyword">let</span> target = targetView&#123;</div><div class="line">                <span class="keyword">if</span> <span class="keyword">let</span> targetController = mainviewController[target]&#123;</div><div class="line">                    <span class="keyword">self</span>.view.addSubview(targetController.view)</div><div class="line"></div><div class="line">                    <span class="comment">//加入手势</span></div><div class="line">                    targetController.view.addGestureRecognizer(gesture)</div><div class="line">                    <span class="comment">//一开始从最右边出现</span></div><div class="line">                    targetController.view.transform = <span class="type">CGAffineTransformMakeTranslation</span>(<span class="keyword">self</span>.view.frame.width, <span class="number">0</span>)</div><div class="line">                    <span class="comment">//然后移到原来的位置</span></div><div class="line">                    <span class="type">UIView</span>.animateWithDuration(<span class="number">0.4</span>, animations: &#123; [<span class="keyword">unowned</span> <span class="keyword">self</span>] <span class="keyword">in</span></div><div class="line">                        targetController.view.transform = originTransform</div><div class="line">                        &#125;)</div><div class="line"></div><div class="line">                    <span class="keyword">self</span>.activeMainViewControler = targetController</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//没有旧view，就是第一次启动</span></div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">if</span> <span class="keyword">let</span> target = targetView&#123;</div><div class="line">                <span class="keyword">if</span> <span class="keyword">let</span> targetController = mainviewController[target]&#123;</div><div class="line">                    <span class="keyword">self</span>.view.addSubview(targetController.view)</div><div class="line">                    <span class="comment">//加入手势</span></div><div class="line">                    targetController.view.addGestureRecognizer(gesture)</div><div class="line">                    <span class="keyword">self</span>.activeMainViewControler = targetController</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//4月20日新增，侧滑栏底下碰到可以收回去，体验更友好</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">gestureBtnclicked</span><span class="params">()</span></span>&#123;</div><div class="line">        leftBarButtunClicked()</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">//可以改进的地方：并未检测用户滑动速度</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<h4 id="手机号码的鉴定"><a href="#手机号码的鉴定" class="headerlink" title="手机号码的鉴定"></a>手机号码的鉴定</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">isTelNumber</span><span class="params">(num:String)</span></span>-&gt;<span class="type">Bool</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">var</span> mobile = <span class="string">"^1(3[0-9]|5[0-35-9]|8[025-9])\\d&#123;8&#125;$"</span></div><div class="line">    <span class="keyword">var</span>  <span class="type">CM</span> = <span class="string">"^1(34[0-8]|(3[5-9]|5[017-9]|8[278])\\d)\\d&#123;7&#125;$"</span></div><div class="line">    <span class="keyword">var</span>  <span class="type">CU</span> = <span class="string">"^1(3[0-2]|5[256]|8[56])\\d&#123;8&#125;$"</span></div><div class="line">    <span class="keyword">var</span>  <span class="type">CT</span> = <span class="string">"^1((33|53|8[09])[0-9]|349)\\d&#123;7&#125;$"</span></div><div class="line">    <span class="keyword">var</span> regextestmobile = <span class="type">NSPredicate</span>(format: <span class="string">"SELF MATCHES %@"</span>,mobile)</div><div class="line">    <span class="keyword">var</span> regextestcm = <span class="type">NSPredicate</span>(format: <span class="string">"SELF MATCHES %@"</span>,<span class="type">CM</span> )</div><div class="line">    <span class="keyword">var</span> regextestcu = <span class="type">NSPredicate</span>(format: <span class="string">"SELF MATCHES %@"</span> ,<span class="type">CU</span>)</div><div class="line">    <span class="keyword">var</span> regextestct = <span class="type">NSPredicate</span>(format: <span class="string">"SELF MATCHES %@"</span> ,<span class="type">CT</span>)</div><div class="line">    <span class="keyword">if</span> ((regextestmobile.evaluateWithObject(num) == <span class="literal">true</span>)</div><div class="line">        || (regextestcm.evaluateWithObject(num)  == <span class="literal">true</span>)</div><div class="line">        || (regextestct.evaluateWithObject(num) == <span class="literal">true</span>)</div><div class="line">        || (regextestcu.evaluateWithObject(num) == <span class="literal">true</span>))</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h4 id="遗留的问题"><a href="#遗留的问题" class="headerlink" title="遗留的问题"></a>遗留的问题</h4><p>在viewdidload里面实例化另一个controller，然后把这个controller里面的一个IBoutlet的view加到主controller的view里面，此时这个子controller的所有IBoutlet都是nil。然而把这个子controller直接的view直接加到主view里面却没问题，操蛋！</p>
<p> // MARK: - Table view data source<br>insertSubview 和 addSubview 的区别？<br>tableview里面的定位，图片怎么缩小恢复到那个位置</p>
<p>self.addChildViewController(mainPageViewController)  //这个好像只有在tabbarController里面有用？self.selectedIndex = index可以切换到相应的childView</p>
<p>//这个可以把主view编程scrollview？<br>    override func loadView() {<br>        super.loadView()<br>        var scrollView:UIScrollView = UIScrollView(frame:super.view.frame)<br>        self.view = scrollView<br>    }</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;IOS开发已经搞了两个月，积累了一些经验。详实记录，以供查阅。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>鼠须管配置指南</title>
    <link href="http://Rocklu.me/2015/05/16/%E9%BC%A0%E9%A1%BB%E7%AE%A1%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%97/"/>
    <id>http://Rocklu.me/2015/05/16/鼠须管配置指南/</id>
    <published>2015-05-16T15:46:00.000Z</published>
    <updated>2016-03-29T09:40:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>鼠须管是什么？鼠须管是一款开源的、跨平台的中文输入法。在windows下叫「小狼毫」。（都是古代著名的毛笔的名字）那么，弃用已经挺好用的「搜狗拼音」的理由是什么呢？1.高度可定制。2.搜狗强制收集你的打字记录。<br><a href="http://rime.im" style="color:blue" target="_blank" rel="external">下载链接</a></p>
<a id="more"></a>
<p>这款输入法的配置真是非常的用户不友好，为什么呢？所有的配置，都要编辑配置文件！你敢信？<code>yaml</code>格式的。我看了都是皱起眉头的，别说是普通用户了。<br>官方文档说的也是事无巨细，看了半天不明白，网上也大都是对于界面的简单设置，而我觉得比较有特色的，「字符映射」的设置一时却没有发现。我自己看繁体的文档摸索了半个小时才搞定……现在觉得还是蛮值得的，配置好以后这个输入法的确非常高效。我把常用的特殊字符全都映射到西文上，这样我在写markdown或者中文代码注释的时候，不用频繁切换中英文。大赞！<br>后记，官方文档右上角其实是可以切换到「简体」的。</p>
<h4 id="模式设置"><a href="#模式设置" class="headerlink" title="模式设置"></a>模式设置</h4><p>在中文输入模式下，按下组合键：<code>control + ~</code><br>里面可以设置输入方案，如「明月」「仓颉」等（区别暂不明）。<br>也包含：简体中文，全角半角等。<br><code>特别注意：</code>这里选自了某个方案，就会去调用相应的配置文件。改设置的时候注意选择正确的配置文件。我刚才就是看着文档改了半天没用……后来才发现我选择了简体字的方案，改那个默认的当然没用……</p>
<h4 id="界面设置"><a href="#界面设置" class="headerlink" title="界面设置"></a>界面设置</h4><p>点击<code>setting</code>可以看到一个配置文件的文件夹。里面的<code>squirrel.yaml</code>就是管界面配置的。这个写得比较直观，我做了如下改动：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="attr">color_scheme:</span> luna  //这个是自带的黑色theme</div><div class="line"><span class="attr">horizontal:</span> <span class="literal">true</span>  //已经习惯了横向候选字了</div><div class="line"><span class="attr">font_point:</span> <span class="number">18</span>  //我觉得原来默认的太大。。。</div></pre></td></tr></table></figure></p>
<h4 id="字符映射"><a href="#字符映射" class="headerlink" title="字符映射"></a>字符映射</h4><p>鼠须管支持的自定义非常详细，甚至源码都给你你可以自己编译。但是我觉得对我有意义的高级自定义大概就这一个了吧。<br>我选择了「明月简体」方案，主配置文件为：<code>luna_pinyin_simp.schema.yaml</code><br>里面一大堆设置，找到关于字符的：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="attr">punctuator:</span></div><div class="line"><span class="attr">  import_preset:</span> default</div></pre></td></tr></table></figure></p>
<p>意思是import那个名为default.yaml的文件的配置。打开这个文件，可以看到里面一大堆映射表。<br>对于中文的引号，他原本在default.yaml里面是这样的：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">'['</span> : [ 「, 【, 〔, ［ ]</div></pre></td></tr></table></figure></p>
<p>意思就是按下这个键，给你这么四个选。我不需要选，我只要直接出第一个就行，于是我自定义直接打上「符号。后面四个也是这样。但是直接改这个表好像是无效的。</p>
<p>需要自定义一个<code>luna_pinyin_simp.custom.schema.yaml</code>，里面书写需要更改的「补丁」：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="attr">patch:</span></div><div class="line">  punctuator/half_shape:</div><div class="line">    <span class="string">"["</span> : <span class="string">"「"</span></div><div class="line">    <span class="string">"]"</span> : <span class="string">"」"</span></div><div class="line">    <span class="string">'\' : "、"</span></div><div class="line">    '/<span class="string">' : '</span>/<span class="string">'</span></div><div class="line">    '~<span class="string">' : '</span>~<span class="string">'</span></div></pre></td></tr></table></figure></p>
<p>这部做好以后保存。再次进入<code>luna_pinyin_simp.schema.yaml</code>：<br>在原来字符的后面再次增加这个配置（我不知道为什么刚刚在custom里写了，这里为什么还要重复配置，但是亲测不写不行）<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="attr">punctuator:</span></div><div class="line"><span class="attr">  import_preset:</span> default</div><div class="line"><span class="attr">  half_shape:</span></div><div class="line">    <span class="string">"["</span> : <span class="string">"「"</span></div><div class="line">    <span class="string">"]"</span> : <span class="string">"」"</span></div><div class="line">    <span class="string">'\' : "、"</span></div><div class="line">    '/<span class="string">' : '</span>/<span class="string">'</span></div><div class="line">    '~<span class="string">' : '</span>~<span class="string">'</span></div></pre></td></tr></table></figure></p>
<p>保存，退出。然后点击菜单上面的「重新部署」。</p>
<p>enjoy！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;鼠须管是什么？鼠须管是一款开源的、跨平台的中文输入法。在windows下叫「小狼毫」。（都是古代著名的毛笔的名字）那么，弃用已经挺好用的「搜狗拼音」的理由是什么呢？1.高度可定制。2.搜狗强制收集你的打字记录。&lt;br&gt;&lt;a href=&#39;http://rime.im&#39; style=&#39;color:blue&#39;&gt;下载链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://Rocklu.me/categories/Tools/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="http://Rocklu.me/2015/04/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%A5%E9%97%A8/"/>
    <id>http://Rocklu.me/2015/04/09/设计模式入门/</id>
    <published>2015-04-09T15:45:00.000Z</published>
    <updated>2016-03-29T09:41:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>有幸听到侯捷老师的面授，不敢懈怠。可惜只有短短8次课，只能做个入门。<br>课件链接：<a style="text-decoration:none; color:blue;" href="http://pan.baidu.com/s/1o6625ei" target="_blank" rel="external">DesignPatterns_2014.pdf</a><br>其中，正红色文字是我自己加的注释。</p>
<a id="more"></a>
<h4 id="什么是设计模式？"><a href="#什么是设计模式？" class="headerlink" title="什么是设计模式？"></a>什么是设计模式？</h4><p>设计模式，是从既有开发经验中抽取出来的，对于既有问题的解决方法的范式。<br>通常所说的设计模式，是指GOF(gane of four)四个人编写的《Design Patterns》中提到的23个设计模式。<br>设计模式的实现，需要编程语言支持<code>面向对象</code>的功能。<br>[另外]对于设计模式后面小括号中的数字，通常指这本书的页码。<br>[经典书]</p>
<ol>
<li>Design Patterns – GOF</li>
<li>Refactoring – Martin Fowler</li>
<li>Refactoring to Patterns – Josiua Kerievsky</li>
<li>Modern C++ Design – Andrel Alexandrescu</li>
<li>Small Memory Software – James Nobles</li>
<li>More effective C++ – Scott Meyers</li>
</ol>
<hr>
<h4 id="Class之间的三种关系"><a href="#Class之间的三种关系" class="headerlink" title="Class之间的三种关系"></a>Class之间的三种关系</h4><p>_</p>
<h5 id="composition-复合"><a href="#composition-复合" class="headerlink" title="composition-复合"></a>composition-复合</h5><p>A持有B的实体，则AB的关系为复合。<br>[注意]两者的生命期完全相同</p>
<h5 id="Delegation-委托"><a href="#Delegation-委托" class="headerlink" title="Delegation-委托"></a>Delegation-委托</h5><p>A持有指向B的指针，则A是<code>委托者</code>，B是<code>受托者</code>或<code>代理</code>。即，A向B传递信息，委托这个任务给代理B处理。<br>[注意]两者生命周期不同<br>[例子]一个窗口（委托者），持有一个绘图类（受托者）的指针，把绘图的这部分任务委托给绘图类做。<code>那么为什么需要用指针而不是直接持有呢？</code>因为这个指向绘图类的指针，将来是可以指向任何一个该类的<code>子类</code>的，只要继承自该绘图类的子类，后期都是可以更换使用的！</p>
<h5 id="Inheritance-继承"><a href="#Inheritance-继承" class="headerlink" title="Inheritance-继承"></a>Inheritance-继承</h5><p>没啥说的。。。。</p>
<hr>
<h4 id="OOP开发的六大守则（课程只提两个）"><a href="#OOP开发的六大守则（课程只提两个）" class="headerlink" title="OOP开发的六大守则（课程只提两个）"></a>OOP开发的六大守则（课程只提两个）</h4><p>_</p>
<h5 id="OCP-open-closed-principle-开放封闭守则"><a href="#OCP-open-closed-principle-开放封闭守则" class="headerlink" title="OCP (open-closed principle, 开放封闭守则)"></a>OCP (open-closed principle, 开放封闭守则)</h5><p>对扩充开放，对修改封闭。<br>意思是，class写完以后，要能够有灵活度以后能加新的功能，但是不应该需要修改原来写好的代码。<br>[例子]链接库、jar<br>[关键]抽象化</p>
<h5 id="LSP-Liskov-Substitution-principle-里氏替代原则"><a href="#LSP-Liskov-Substitution-principle-里氏替代原则" class="headerlink" title="LSP (Liskov Substitution principle, 里氏替代原则)"></a>LSP (Liskov Substitution principle, 里氏替代原则)</h5><p>父类能用的场合，子类一定能用。（子类 <code>is a</code> 父类）<br>用在什么地方呢？就是有时候考虑要借用一个写好类的功能时，要继承呢？还是要复合呢？的时候考虑这个准则来判定要不要使用继承。</p>
<hr>
<h4 id="关于类图"><a href="#关于类图" class="headerlink" title="关于类图"></a>关于类图</h4><p>类图有多种流派，这里解释UML风格的类图</p>
<h5 id="类表示"><a href="#类表示" class="headerlink" title="类表示"></a>类表示</h5><p>方框，第一行类名，第二行类数据，第三行类方法。<br>不必写全，只写需要描述的部分。<br>如果没有类数据或类方法，空白即可。<br>如果是<code>斜体</code>的函数，是虚函数<br>如果有<code>下划线</code>，表示static成员</p>
<h5 id="类关系"><a href="#类关系" class="headerlink" title="类关系"></a>类关系</h5><p><code>菱形</code>标记代表持有，实心是持有实体（复合），空心是持有指针（委托）<br><code>剪头</code>指向一个类，代表继承自这个类<br><code>实线</code>拖出来的方块，代表对某个函数的伪代码片段</p>
<hr>
<h4 id="Template-Method"><a href="#Template-Method" class="headerlink" title="Template Method"></a>Template Method</h4><p>Define the skeleton of an algorithm in an operation, <code>deferring</code> some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm’s structure.</p>
<p>最常见的就是在设计application framework的时候，把大部分通用的流程写好，留出一些需要更改的部分，以<code>虚函数</code>的方式留在那里，俗称“孔”。然后开发者在使用这些类库的时候，只需要<code>重写</code>或<code>实现</code>这些孔，就能做到写很少代码作出一个完整的应用。<br>所谓template，就是类库里面的那种通用流程的函数，template函数里面会调用到孔函数。</p>
<p>[实现]某些个性化功能的函数写成virtual，让子类去实现覆盖<br>[另]framwork有很多种，appliation framwork是用来帮助创建apllication的framwork。好像废话。。。</p>
<hr>
<h4 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h4><p>Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.<br>[侯捷注]上面英文的定义有问题，实际上，notify是一定的，update是可选的。<br>所谓one-to-many，one指被观察者，many指观察者。被观察者发生变化的时候，它有责任告诉所有观察者自己发生了变化，让观察者处理变化。有点像信息推送、报纸订阅。<br>[实现]</p>
<ul>
<li><strong>被观察者需要实现的功能</strong><ol>
<li>存放观察者的容器，如：vector。一般持有指向观察者的<code>指针</code>。</li>
<li>增加观察者。即让观察者注册，我需要知道你的变化。</li>
<li>删除观察者。即，退订</li>
<li>通知观察者。push message。这里要调用观察者的某个方法。这个方法是协定好的。</li>
<li>一个flag，标记是否发生过变化。changed</li>
</ol>
</li>
<li><strong>观察者需要实现：</strong><ol>
<li>实现由被观察者调用的那个方法，对被观察者的变化进行处理。这个函数通常会把指向被观察者的指针当作一个函数传递过来，有时还会传递一个hint，告诉你我具体修改了哪些数据。<br>[使用]<br>一般库函数会写好一个观察者类一个被观察者类，只要从他们继承，然后实现通知方法，就能实现功能。</li>
</ol>
</li>
</ul>
<hr>
<h4 id="Adapter"><a href="#Adapter" class="headerlink" title="Adapter"></a>Adapter</h4><p>Convert the interface of a class into another interface clients expect. Adapter lets classes work together that couldn’t otherwise because of incompatible interfaces.<br>望文生义，适配器。就是用一些浅层的包装，让以前写好的类能够用到新的地方。<br>从实现方式来说，有Class Adapter（用继承实现）和Object Adapter（用复合或委托实现）<br>[注]那么，我们要继承还是不要继承呢？请参考LSP准则<br>从功能来说，有Container Adapters, Function Adapters, Iterator Adapters。</p>
<p>[名词注解]<br>adapter—-适配器<br>adaptee—-原来的对象，被适配的对象<br>adaptable—-可以被适配器适配的能力</p>
<h5 id="Container-Adapters"><a href="#Container-Adapters" class="headerlink" title="Container Adapters"></a>Container Adapters</h5><p>例如把dequeue改成一个stack这种简单的应用<br>实现上，可以是继承，也可以是复合。主要是调用原来容器的方法，适配新的方法。</p>
<h5 id="Funcion-Adapters"><a href="#Funcion-Adapters" class="headerlink" title="Funcion Adapters"></a>Funcion Adapters</h5><p>重用以前写好的函数，通过绑定某些参数（固定参数的值），或者更换参数的顺序，使其能用于现在的应用。<br>问题在于，函数的实参不是在调用的时候才确定的吗？为什么可以事先绑定呢？<br>答案是这样的：函数适配器其实不是一个函数，也不是一个函数指针。它是一个class，function object，这种类，由于重载了<code>()</code>小括号运算符，所以<code>表现得像一个函数</code>。是一个class呢，就能够把预先输入的参数，作为class的data储存起来，当需要调用的时候，就是除法这个小括号重载函数的时候，再把这个预先输入的（绑定的）值拿出来，放到那个需要适配的函数的实参里面去。</p>
<p>思路是比较简单的，实现起来还是蛮复杂的。复杂度主要来自于这个适配器是范型的，对于类型的判断和传递挺费劲。<br>[实现]<br>对于适配器来说，我需要最后表现为一个函数，那么就像前面提到的，我需要是一个function object，我要实现：1.持有适配的adaptee函数，2.持有需要绑定的具体的参数，3.一个小括号的重载来使用绑定的参数来调用adaptee函数。</p>
<p>但是问题来了，我事先不知道你这个adaptee的参数类型，我怎么知道我要绑定的参数的类型呢？于是adaptee必须要有让adapter查询参数类型的接口。C++STL的解决方案是让所有想adaptable的class全都继承一种很奇怪的struct（如：<code>unary_fuction</code>, <code>binary_fuction</code>），这种struct呢，里面只有几个typedef，它自己本身也是范型的。这种struct干什么呢，就是让需要adaptable的class呢，在继承它的时候，就把自己的参数啊、返回值这种类型全都交给它，然后它有几个typedef把这几个类型别名为一组<code>标准的</code>名字（<code>first_argument_type</code>），将来供adapter询问（查询）。于是，adapter只要进入adaptee的命名空间，就可以访问到这个adaptee的父类，就是那个怪怪的struct，然后用那个标准的名字就可以知道adaptee的参数类型啊、返回值啊之类的了。[另]得到的这个类型，可以直接用哦，像什么加个小括号就是构造函数可以构造这个类的实例啊之类的。</p>
<p>最后呢，这个adapter有可能并不是最终产品啊，或许我们需要再将其适配，所以，它也需要adaptable，于是，它也要继承那个怪怪的struct。</p>
<p>[注意]对于范型的function object来说，func<type>()是它的实例，func<type>是它的类型，在形式上还是比较迷惑的。表老把它想成函数指针了，人家是一种class。</type></type></p>
<hr>
<h4 id="Composite"><a href="#Composite" class="headerlink" title="Composite"></a>Composite</h4><p>Compose objects into tree structures to represent part-whole hierarchies. Composite lets clients treat individual objects and compositions of objects <code>uniformly</code>.<br>复合设计模式的精髓，在于组成树形结构的时候，以<code>一致的方式</code>对待单一物件和复合物件。<br>[注释]<br>复合物件，指的是单一物件的容器，例如文件夹<br>单一物件，即文件。<br>所谓树形结构，即文件夹内既可以放文件，也可以放文件夹。<br>一致的方式，就是在操作文件夹时，用同一组函数（方法）对待文件夹和普通文件。但是同样的函数，对于单一物件，应该可以直接得到返回值，而对于复合物件，就可能是递归的形式。</p>
<p>[例子]<br>File system<br>Windowing system – 窗体内嵌套窗体，也可以增加物件<br>Command – 命令中嵌套命令，也有参数</p>
<p>[实现]<br>对于<code>一视同仁</code>的阐释，又两个方面：<br>首先 ，复合物件里面必须要有容器。容器必须既可以装复合物件又可以装单一物件。<br>其次 ，复合物件和单一物件必须要有相同的API。</p>
<p>那么解决方法显而易见：让它们<code>共同继承</code>一个父类。然后复合物件的容器可以存放<code>指向父类的指针</code>。再者，两者公共的API可以在父类中定义<code>虚方法</code>，由两个子类各自去实现自己的版本。</p>
<p>[另外]这里有个常见的小技巧，对于个别物件不应该定义的方法（例如增加子物件），也抽离出来，在上层父类中定义，并把这个方法的内容写成<code>抛出异常</code>。然后，让复合物件重写这个方法。于是，如果个别物件调用了这个方法自然抛出异常。</p>
<hr>
<h4 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h4><p>Provide a way to access the elements of an aggregate object sequentially without exposing its underlying representation.<br>[注释]aggregate：容器，即container<br>迭代器模式，专门用在对容器的遍历。希望把容器的构造抽象，提供给外界<code>统一的接口</code>，遍历容器。<br>C++的迭代器，是一种行为像指针一样的class。</p>
<p>[实现]<br>首先，对于每一种容器，只有它自己才直到要怎么去遍历自己。于是，每个容器都应该定义自己的迭代器。</p>
<p>其次，对于一个实际的容器，这个用于遍历的“指针”，对于不同的访问者来说，不应该是唯一的、公用的，而应该是给每个访问者创建一个，你遍历你的，他遍历它的。于是，迭代器不应该写死在容器里，也不应该让容器持有指向迭代器的指针（因为数量是未知的）。那怎么办呢？给每一种容器，特别定义一个专属的迭代器class。Java中，当访问者需要一个迭代器时，由容器为其创造一个。而在C++中，在容器的命名空间中的typedef提供了迭代器的类型名称，由用户手动创建。大同小异。</p>
<p>对于迭代器而言，为了表现得像一个指针，则需要重载应用于指针得操作符，对外提供统一得API。</p>
<hr>
<h4 id="内存管理-Memory-Pool"><a href="#内存管理-Memory-Pool" class="headerlink" title="内存管理(Memory Pool)"></a>内存管理(Memory Pool)</h4><p>Memory Pool并不属于GOF的23种设计模式之列，但是也非常重要。</p>
<h5 id="背景知识－内存分配"><a href="#背景知识－内存分配" class="headerlink" title="背景知识－内存分配"></a>背景知识－内存分配</h5><p>[调用的层次关系：]<br><code>Applications</code> -&gt; <code>C++Library</code>(Stl,Boost) -&gt; <code>C++Primitives</code>(new) -&gt; <code>CRT</code>(c runtime) -&gt; <code>OS api</code>(HeapAlloc)</p>
<p>[内存管理实现（bookkeeping）]<br>CRT并没有像操作系统那样，对分配出去的内存用专门的数据结构记录管理。那么CRT怎么在free的时候，知道这个指针指向的地址，当初分配了多大空间给他呢？答案是在分配出去指针前面藏一个<code>cookie</code>，大小一般是4B。于是在free的时候，往前面看下cookie，就知道应该去释放多大的内存了。<br>[注释]忘记在哪里看到的cookie的来源，可能是西方什么故事的典故，主要意思是：小孩子来我家里玩，然后走的时候我把我自己做的cookie给她们带回去吃，每个小孩都给一种不一样的cookie。然后走了就走了，我也不去记住每个小孩的样子。但是以后每当再有小孩来的话，只要他带着我当时给他的cookie，我就知道他曾经来过，也知道他是谁啦～</p>
<h5 id="背景知识－C-中的new操作符"><a href="#背景知识－C-中的new操作符" class="headerlink" title="背景知识－C++中的new操作符"></a>背景知识－C++中的new操作符</h5><p>在C++中，new操作会被编译器翻译为三个动作：（以new className()为例）</p>
<ol>
<li>调用<code>::operator new()</code>分配一块内存。（参数是sizeof(className)）</li>
<li>把返回的指针<code>static_cast</code>至className类型</li>
<li>调用className的<code>构造函数</code><br>[另外]</li>
<li><code>::operator new()</code>这个全局函数是可以重载的，既可以是全局重载，也可以是在某个特定的class里面重载。</li>
<li>所有的内存分配操作，最后都会调用<code>malloc()</code></li>
<li>上面三个步骤如果失败，会抛出异常std::bad_alloc</li>
</ol>
<p>[关于<code>delete[]</code>中的方括号]<br>这叫<code>array new</code>、<code>array delete</code><br>加了方括号，会对地址内每个元素调用析构函数。不加，则仅对第一个元素调析构。<br>所以问题就是出在要析构的class上。对于持有指向heap指针的class，仅仅调用free释放这个class本身是不够的。对于这种类型的数组，delete的时候务必加方括号。一个好习惯是：new的时候有方括号，那么delete的时候也要有。</p>
<p>不加方括号也正确的例子：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</div><div class="line"><span class="keyword">delete</span>[] p;</div></pre></td></tr></table></figure></p>
<p>首先明确，delete和new类似，最后调用的是free()。对于由array new产生的p指向的空间，p前面的cookie会正确纪录分配给p的空间大小，是3份的int。所以无论这个delete加不加方括号，只要调用了free，free就会读取cookie，得到正确的空间大小，就能正确释放。</p>
<h5 id="Memory-Pool"><a href="#Memory-Pool" class="headerlink" title="Memory Pool"></a>Memory Pool</h5><p>[为啥要有memory pool]?</p>
<ol>
<li>对于小型class，4B的cookie代价太大</li>
<li>虽然malloc的实现各不相同，对于各种<code>不同的大小</code>的内存分配／归还，产生大量碎片。</li>
<li>系统调用的成本</li>
</ol>
<p>[memory pool思想]（focus on <code>SGI allocator</code>）<br>回想一下操作系统中的内存管理，其实思想有点类似于<code>分页存储</code>。<br>虽然用户提出的内存要求是不确定的，但是我们把内存以<code>固定大小的block</code>来配给内存。把外碎片变成内碎片。同时，由于大小是固定的，那我也不用cookie来纪录当时给了多大。这样可以解决前两个问题。<br>对于频繁的系统调用，请回想<code>printf,scanf</code>不管你要多少数据，我先读一大片进缓冲区，当你下次再要的时候，就不用再系统调用了。memory pool也是这个缓冲的思想，只不过pool是那种用完了还可以放进去循环利用的感觉，buffer就是一次性的。</p>
<p>[SGI allocator的实现概要]</p>
<ol>
<li>大于128B的请求，直接调用malloc。小于128B的，按照8、16、24…120、128这16种大小分配最合适的一块。</li>
<li>用一个数组，存放16个free_list（单链表）。这每个list，用来纪录对应的16种大小的block的分配情况。另外有两个指针纪录pool的开始和末尾。</li>
<li>分配策略如下：根据请求大小，可知应该去找哪个list要。先看list有没余量block，如果没有，就把pool全都那过来用。如果pool里面的空间都不够，就像系统请求40个当前block大小的内存，20个给list，20个给pool。</li>
<li>关于归还，客户把block还给list，然后就结束了。这个allocator并不归还内存给系统。</li>
<li>对于向系统请求失败的情况，分配器会看看有没有更大的list里面有空block，如果有的话可以借一块过来。<br><strong>注意：</strong>具体实现的细节很多，请看源码。</li>
</ol>
<p>[SGI allocator的缺陷]<br>内存不归还。。。其实是没法归还，因为单链表结构在反复使用后，已经无法判定block们是不是在一块连续的内存空间里面了。<br>[改进]例子：Loki small object allocator，参考书：<morden c++="" design=""><br>block们用<code>静态链表</code>连接，而且少量block就规划为一个chunk。静态链表解决了空间不连续的问题，而对比整个free_list，chunck较小，比较容易形成全空的情况，此时就可以回收归还给OS。<br>提一个细节，这种pool，即使归还内存，一般也会留存一个chunk在手里，以备客户需要。</morden></p>
<p>[应用]<br>其实，有的malloc实现中，也采用了pool的思想，但毕竟是通用的、对各种个样大小都要适合的服务。而allocator用的memory pool，则是对<code>固定大小</code>内存请求的优化（所以经常用在<code>容器</code>中）。</p>
<p>[嗯，那个。。。我不会写这个pool，可是我也想用这个allocator，可以嘛？]<br>可以的哦，亲～方法如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//方法一：重载全局::operator new()</span></div><div class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> alloc::allocate(size); <span class="comment">// get from free-list</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* p, <span class="keyword">size_t</span> size)</span> </span>&#123;</div><div class="line">    alloc::deallocate(p, size); <span class="comment">// return to free-list</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//方法二：重载某个class的operator new()</span></div><div class="line"><span class="comment">//注意这个class只有小于128B，才有意义</span></div><div class="line"><span class="keyword">class</span> MyClass&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> alloc::allocate(size); <span class="comment">// get from free-list</span></div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* p, <span class="keyword">size_t</span> size)</span> </span>&#123;</div><div class="line">        alloc::deallocate(p, size); <span class="comment">// return to free-list</span></div><div class="line">    &#125;</div><div class="line"><span class="comment">//其他成员</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<hr>
<h4 id="Factory-Method"><a href="#Factory-Method" class="headerlink" title="Factory Method"></a>Factory Method</h4><p>Define an interface for creating an object, but let subclasses decide which class to instantiate. Factory Method lets a class <code>defer</code> instantiation to subclasses.<br>又是defer！与Template Method相比，Factory Method延缓的是<code>实例化</code>的动作。主要的应用是在大型框架。大型框架的运作，需要预先对用户派生的子类进行操作。但是用户具体定义的类name预先是不可能知道的。所以这里必须进行抽象化延缓。<br>[注释]Factory Method中，method指的是一个用来创建子类的<code>虚函数</code>。</p>
<p>[问题是什么呢？]<br>框架现在需要实例化这个不知道名字的子类，怎么new呢？[注释]这个动作叫做<code>dynamic creation</code><br>由于C++语言本身的限制，通过一个string变量来制定需要实例化对象的名字是禁止的。我们唯一能做的，就是预先设定好需要实例化的这个class，然后比较后期需要创建class的名字（string），如果string相同，则创建对应的class。可以看出，这个用来比较class name的string，也需要是预先设定好的。</p>
<p>除此之外，就算你的字符串比对成功匹配了，就算现在就是可以调用这个预先写好的new语句了，那这句new写在哪里呢？写框架的人可能有本事把这句话写死再框架代码里吗？不可能，显然必须是写在用户代码里的。写在用户代码里？难道让那个class自己new自己？是的，你没有听错。<br>但是可能吗？我框架连你得class都找不到，怎么去找你class里面写的new？况且，你都没有实例化，怎么调用new函数？</p>
<p>[解决方案]–&gt;隔一层<br>第一个问题，我不是没办法写死那个比较的string嘛？那我可以加一个中间物件，比如一个表，一个list。我去从这个表里吗取名字，而这个表，是deffer到用户那里去填写的。意思就是，我新派生了一个子类，于是我把我子类的名字（string）注册到那个表里面去，然后框架在需要new我的时候，就例行公事去那个表里面检查。good！解决第一个问题。<br>第二个问题，怎么new。这个简单，把这个new语句，写成<code>static方法</code>，则不用实例化也可调用。<br>那怎么调用呢？ 嗯。。。调用函数呢，需要函数的入口地址，对吧？要么，给class name，是一个入口。或者，直接给这个函数地址，也OK，对不？。。。。嗯，有点怪，然后呢？简单啊，把这个自己创建自己的函数指针，直接放到前面提到的那张表里啊！查表，名字对上，取出自己new自己的函数地址，然后调用<code>用户写的</code>new语句，new出来的实例返回给框架，搞定！</p>
<p>[总结]<br>所谓“工厂方法”，指的是一套<code>接口</code>，包括框架维护的一个数据结构，让用户注册。以及用户自己书写的自己new自己的方法。（在框架的中，用户派生类的父类需要定义一个抽象函数强制要求用户定义这个函数。）<br>另外：这个“注册”和“自己创建自己”的动作，由于比较制式，经常由一个常规的宏函数实现（回想QT）。</p>
<hr>
<h4 id="Prototype"><a href="#Prototype" class="headerlink" title="Prototype"></a>Prototype</h4><p>Specify the kinds of objects to create using a prototypical instance, and create new objects by copying this prototype.<br>模板模式也是解决用户子类实例化的问题。但是我不能明白这么做的用意，可能是与工厂方法模式解决类似的问题。但是给出的例子，主要在客户端那边的实例化，不理解。</p>
<p>[什么意思呢]<br>prototype意思是原型，意思是，新定义的子类，在程序开始创建的时候，就<code>自动创建一个“原型”实例</code>，放在父类的容器里。虽然子类可以变化增加，但是因为父类是预先写好的嘛，如果想实例化子类，只要通过找到父类的容器里面的原型，就可以让这个原型new一个新的子类出来（美其名曰：clone函数，其实就是自己new自己）。好像是一个比较优雅的解法？不是嘛？～</p>
<p>[实现]</p>
<ol>
<li>首先，在程序启动时自动创建实例，能做到？可以的，叼的不行了。在子类定义里面，放一个static的自己（static就不算循环定义了？需要复习static）。然后static成员是有一次赋初值的机会的，写在class外面就行，这个动作不需要有人去手动调用它。于是这个初值就构造一个自己。（简直匪夷所思！）实例化好了对吧，然后更happy的来了，在构造函数里面，调用父类的某个函数，把自己放到父类的原型容器里去。天哪，代码还没开始跑，每个子类都已经各就各位了！</li>
<li>于是你也发现了，每个子类都会copy一份父类，如果这个容器不是static的，那么大家会在各自不同的容器里面，这就不happy了。</li>
<li>于是呢，用户拿到父类，容器在手，再无他求啊！</li>
<li>对于框架来说，也是可以通过父类的容器比对或者找到需要实例化的子类的。</li>
</ol>
<p>[另外]<br>具体实现时，常把子类的构造函数写为<code>私有</code>，这样做的想法，可能是想统一用父类的接口，不要让用户去处理子类。美其名曰：解偶。decouple。用户一切的子类创建必须通过父类的容器。</p>
<p>总之呢，是不太理解这个设计模式啦。。。只是觉得手段很精妙！</p>
<hr>
<h4 id="Reference-Counting"><a href="#Reference-Counting" class="headerlink" title="Reference Counting"></a>Reference Counting</h4><p>引用计数，非GOF的23个设计模式之一。主要的目的就是想省内存，即对于需要<code>深拷贝</code>来管理内存的物件，使用<code>写时复制</code>(copy on write)的技术，让用户看上去是深拷贝，而实际上是浅拷贝。只有当用户对拷贝的物件实际进行修改动作时，才真正深拷贝。</p>
<p>[应用]<br>STL的string。swift里面好像都是引用计数啊，还有vfork不知道是不是。<br>另外，引用计数在内存管理中也用到。没有指针指向自己时自动销毁。</p>
<p>[困难]-&gt;我怎么知道有几个人持有指向我的指针呢？<br>一个比较自然的想法，是搞一个用户列表在我自己的这个class里面，每个实例拥有一个表(不要搞成static)，这个表里面纪录着持有自己的对象。</p>
<p>这样做可以达到目的，但是对于使用者来说，需要增加额外的操作，比如在拷贝时，要去你的表里面增加自己，或者在销毁时，检查自己是不是表里面的最后一个，等等。<br>同时也不能做到自己销毁自己。</p>
<p>[解决]<br>我们又想到可以再包装一层，把<code>实际的value</code>与<code>对引用的manager</code>分成两个class，以string为例，把实际的字符串内容单独写到一个class里面，同时这个class再附加一个int字段来纪录自己的引用者。（这样与上面的table做法相比更省事）<br>而另外一个manager，则持有一个value类的引用，让外界持有这个manager，然后这个manager对外只要表现的像一个实际的value就行了（重载相关操作符嘛）。<br>当这个manager被copy时，仅仅做对manager的浅copy，然后让value类的引用计数＋1即可。同样的，manager销毁时，检查value类的引用计数，如果是1，那么除了销毁自己，顺手也把value类销毁掉。</p>
<p>[那么问题来了]-&gt;这样的浅copy，用户是不知道的，如果被改动不是错误了嘛？<br>是的，我们需要实现<code>copy_on_write</code>。<br>那么，我们怎么知道别人要write我了呢？还是重载操作符，对于可能<code>暴露自己handler</code>的，或者<code>直接修改</code>自己的，全都copy一份，再进行相应操作即可。</p>
<p>[问题]<br>你可能注意到了，上面需要真实copy的情况，直接修改自己是没商量的，而对于暴露自己handler的情况，可能用户并没有要修改，此时盲目copy造成资源浪费。但是对于C++语言功能来说，在传出自己handler时，并不能用户是否要进行修改，以决定是否要copy。只能是悲观得认为用户要改，保守操作。</p>
<p>这个问题可用proxy解决。</p>
<hr>
<h4 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h4><p>Provide a surrogate or placeholder for another object to <code>control access to it</code>.<br>[注释]surrogate：代理人<br>我觉得代理人模式也是又deffering的意思，我们不是直接对某个目标物件操作，而是通过这个proxy类来获取、操作目标物件。</p>
<p>有点属性值里面的setter和getter的意思，对代理操作，然后进行相关处理后，再又代理对实际的值进行处理。<br>这样多了一个中间层，可以有很多机会判断。比如在需要的时候再实例化目标啊之类的。</p>
<p>[另外]<br>对于上面引用计数不能解决的问题。（即暴露handler时无法判断用户是不是要修改）。我们可以不返回真实的value类出去，而是返回一个proxy给用户，也是表现的像一个value就行了。然后当这个proxy被修改的时候，再进行真实的copy。这样问题就解决了。</p>
<hr>
<h4 id="总结和反思"><a href="#总结和反思" class="headerlink" title="总结和反思"></a>总结和反思</h4><p>学完了这门课，给我最深刻的印象是，反反复复出现的<code>中间层</code>和<code>统一化</code>的思想。<br>中间层，把变化的、不确定的、暂时不知道的情况，先放置一个中间层，一端确定下来。然后把剩下的另一端不确定的，<code>推迟</code>到实际确定的时候再写清楚。或者一端确定，另一端发生的变化，并不会影响确定的那一端。<br>统一化的处理，可以大大简化工程的难度。</p>
<hr>
<h4 id="关于语言的零散笔记"><a href="#关于语言的零散笔记" class="headerlink" title="关于语言的零散笔记"></a>关于语言的零散笔记</h4><p>C++中reference的实现底层用的指针</p>
<p>java的方法全是虚函数，class全是引用</p>
<p>什么时候需要用虚函数？<br>设计父类时，如果某个方法需要由子类定义，或重新定义，那么应该被设计为虚函数</p>
<p>临时对象的生存期？待深入</p>
<p>java容器能放所有类型，是因为java有单根的继承体系，指向根的指针能指向任何类型</p>
<p>关于const成员函数<br>非const的class，也可以调用const的成员函数。但是会优先调用非const版本。</p>
<p>静态成员变量不会增加实例的size</p>
<p>变量最好在使用的前一刻再定义，特别是迭代器<br>比如：容器空间不够时，会重新分配一块空间（搬家），原来的迭代器指向的内存可能已经废弃。</p>
<p>operator char() const;   //这是重载的类型转换函数，当环境需要char类型时，它调用此函数。注意没有返回值，因为一定是char</p>
<hr>
<h4 id="附录：GOF的23种设计模式"><a href="#附录：GOF的23种设计模式" class="headerlink" title="附录：GOF的23种设计模式"></a>附录：GOF的23种设计模式</h4><p>_</p>
<h5 id="Creational-Patterns"><a href="#Creational-Patterns" class="headerlink" title="Creational Patterns"></a>Creational Patterns</h5><p><strong>Abstract Factory:</strong><br><em>Provide an interface for creating families of related or dependent objects without specifying their concrete classes.</em><br>提供一个创建一系列相关或相互依赖对象的接口,而无需指定它们具体的类。</p>
<p><strong>Builder:</strong><br><em>Separate the construction of a complex object from its representation so that the same construction process can create different representations.</em><br>将一个复杂对象的构建与它的表示分离，这样使得同样的构建过程可以创建不同的表示。</p>
<p><strong>Factory Method:</strong><br><em>Define an interface for creating an object, but let subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses.</em><br>定义一个用于创建对象的接口，让子类决定将哪一个类实例化。工厂方法模式使一个类的实例化延迟到子类。</p>
<p><strong>Prototype:</strong><br><em>Specify the kinds of objects to create using a prototypical instance, and create new objects by copying this prototype.</em><br>用原型实例指定创建对象的种类,并且通过拷贝这个原型来创建新的对象。</p>
<p><strong>Singleton:</strong><br><em>Ensure a class only has one instance, and provide a global point of access to it.</em><br>保证一个类仅有一个实例,并提供一个访问它的全局访问点。</p>
<h5 id="Structual-Patterns"><a href="#Structual-Patterns" class="headerlink" title="Structual Patterns"></a>Structual Patterns</h5><p><strong>Adapter:</strong><br><em>Convert the interface of a class into another interface clients expect. Adapter lets classes work together that couldn’t otherwise because of incompatible interfaces.</em><br>将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p>
<p><strong>Bridge:</strong><br><em>Decouple an abstraction from its implementation so that the two can vary independently.</em><br>将抽象部分与它的实现部分分离,使它们都可以独立地变化。</p>
<p><strong>Composite:</strong><br><em>Compose objects into tree structures to represent part-whole hierarchies. Composite lets clients treat individual objects and compositions of objects uniformly.</em><br>把物件组合成树形结构，以表示“部分－整体”的层次结构。复合模式使得用户一致地对待复合物件和单一物件。</p>
<p><strong>Decorator:</strong><br><em>Attach additional responsibilities to an object dynamically. Decorators provide a flexible alternative to subclassing for extending functionality.</em><br>將額外的「职责、任務、负担」以动态方式附著於物件身上,使不必進行subclassing就能扩展功能。</p>
<p><strong>Facade:</strong><br><em>Provide a unified interface to a set of interfaces in a subsystem. Facade defines a higher-level interface that makes the subsystem easier to use.</em><br>为子系统中的一组接口提供一个一致的界面,Facade模式定义了一个高层接口,这个接口使得这一子系统更加容易使用。</p>
<p><strong>Proxy:</strong><br><em>Provide a surrogate or placeholder for another object to control access to it.</em><br>为其他对象提供一个代理以控制对这个对象的访问。</p>
<h5 id="Behavioral-Patterns"><a href="#Behavioral-Patterns" class="headerlink" title="Behavioral Patterns"></a>Behavioral Patterns</h5><p><strong>Chain of Responsibility:</strong><br><em>Avoid coupling the sender of a request to its receiver by giving more than one object a chance to handle the request. Chain the receiving objects and pass the request along the chain until an object handles it.</em><br>为解除请求的发送者和接收者之间耦合,而使多个对象都有机会处理这个请求。将这些对象连成一条链,并沿着这条链传递该请求,直到有一个对象处理它。</p>
<p><strong>Command:</strong><br><em>Encapsulate a request as an object, thereby letting you parameterize clients with different requests, queue or log requests, and support undoable operations.</em><br>将一个请求封装为一个对象,从而使你可用不同的请求对客户进行参数化;对请求排队或记录请求日志,以及支持可取消的操作。</p>
<p><strong>Interpreter:</strong><br><em>Given a language, define a represention for its grammar along with an interpreter that uses the representation to interpret sentences in the language.</em><br>给定一个语言,定义它的文法的一种表示,并定义一个解释器,该解释器使用该表示来解释语言中的句子。</p>
<p><strong>Iterator:</strong><br><em>Provide a way to access the elements of an aggregate object sequentially without exposing its underlying representation.</em><br>提供一种方法顺序访问一个聚合对象中各个元素,而又不需暴露该对象的内部表示。</p>
<p><strong>Mediator:</strong><br><em>Define an object that encapsulates how a set of objects interact. Mediator promotes loose coupling by keeping objects from referring to each other explicitly, and it lets you vary their interaction independently.</em><br>用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用,从而使其耦合松散,而且可以独立地改变它们之间的交互。</p>
<p><strong>Memeneto:</strong><br><em>Without violating encapsulation, capture and externalize an object’s internal state so that the object can be restored to this state later.</em><br>在不破坏封装性的前提下,捕获一个对象的内部状态,并在该对象之外保存这个状态。这样以后就可将该对象恢复到保存的状态。</p>
<p><strong>Observer:</strong><br><em>Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.</em><br>定义对象间的一种一对多的依赖关系,以便当一个对象的状态发生改变时,所有依赖于它的对象都得到通知并自动刷新。</p>
<p><strong>State:</strong><br><em>Allow an object to alter its behavior when its internal state changes. The object will appear to change its class.</em><br>允许一个对象在其内部状态改变时改变它的行为。让这个对象看起来似乎修改了它所属的类。</p>
<p><strong>Strategy:</strong><br><em>Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it.</em><br>定义一系列的算法,把它们一个个封装起来,并且使它们可相互替换。本模式使得算法的变化可独立于使用它的客户。</p>
<p><strong>Template Method:</strong><br><em>Define the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm’s structure.</em><br>定义一个操作中的算法的骨架,而将一些步骤延迟到子类中。Template Method使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p>
<p><strong>Visitor:</strong><br><em>Represent an operation to be performed on the elements of an object structure. Visitor lets you define a new operation without changing the classes of the elements on which it operates.</em><br>表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有幸听到侯捷老师的面授，不敢懈怠。可惜只有短短8次课，只能做个入门。&lt;br&gt;课件链接：&lt;a style=&quot;text-decoration:none; color:blue;&quot; href=&quot;http://pan.baidu.com/s/1o6625ei&quot;&gt;DesignPatterns_2014.pdf&lt;/a&gt;&lt;br&gt;其中，正红色文字是我自己加的注释。&lt;/p&gt;
    
    </summary>
    
      <category term="基础理论" scheme="http://Rocklu.me/categories/%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/"/>
    
    
  </entry>
  
</feed>
