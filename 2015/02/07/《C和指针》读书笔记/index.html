<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 《C和指针》读书笔记 · Rock's personal notebook</title><meta name="description" content="《C和指针》读书笔记 - Rock Lu"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/u/1565858217" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/rulerstorm" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li><li class="nav-list-item"><a href="/impress/index.html" target="_self" class="nav-list-link">TEST</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">《C和指针》读书笔记</h1><div class="post-time">Feb 7, 2015</div><div class="post-content"><p>之所以再学C语言，目的是希望编写<code>跨平台可移植的C语言</code>。听起来似乎有点奇怪，C语言不是高级语言吗？难道本来就不该是跨平台可移植的吗？<br>答案显然不是，C语言仍然不够“高级”，涉及到底层的细节时，往往会由于编译器、机器的差异，在移植的时候出现问题。另外关于跨平台，其实是我自己的问题，之前学得时候和Linux网络编程一块儿学的，于是就有点分不清哪些是Linux的特有函数，哪些是ANSI C的通用函数。导致写出来得东西在Windows上面编译不动。</p>
<a id="more"></a>
<h4 id="可移植性建议"><a href="#可移植性建议" class="headerlink" title="可移植性建议"></a>可移植性建议</h4><p>也包含一些防止出错的细节。</p>
<h5 id="一、数据类型"><a href="#一、数据类型" class="headerlink" title="一、数据类型"></a>一、数据类型</h5><p>不同的编译器和机器上数据定义有差异，了提高可移植性：</p>
<ol>
<li>数据类型的长度可能不同—用<code>int32_t</code>、<code>uint8_t</code>代替原来的<code>int</code>和<code>unsigned char</code>。</li>
<li>char不确定是不是有符号—不超过127时安全，否则强制申明有没有符号<br>另外：</li>
<li>本机数据类型的最大值，在<code>limits.h</code>和<code>float.h</code>中有宏定义（如：INT_MAX、FLT_MAX）</li>
<li>「数字常量」默认是int，存不下就unsigned int、long往上加。（<code>EOF = -1</code> 是int类型！）</li>
</ol>
<h5 id="二、底层操作"><a href="#二、底层操作" class="headerlink" title="二、底层操作"></a>二、底层操作</h5><ol>
<li>「移位操作」究竟是<code>算数移位</code>还是<code>逻辑移位</code>不一定。但两者仅在<code>有符号数</code>的<code>右移</code>操作有差异。（有符号补符号位，无符号补0）</li>
<li>「位段」数据类型是不可移植的。</li>
</ol>
<h5 id="三、溢出"><a href="#三、溢出" class="headerlink" title="三、溢出"></a>三、溢出</h5><ol>
<li>小心无符号数减法</li>
<li>大数字「加法」和「乘法」时，在运算前就强转为大数据类型比较安全</li>
</ol>
<h5 id="四、类型转化"><a href="#四、类型转化" class="headerlink" title="四、类型转化"></a>四、类型转化</h5><p>「截短」是直接取长数据的低位。<br>「扩展」是根据短数据是否有符号，无符号补0，有符号补符号位。<br><code>隐式类型转化一定要小心！！</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">看一个经典的例子：</span><br><span class="line"><span class="comment">//关于char转int可能发生的问题</span></span><br><span class="line"><span class="keyword">char</span> buf;</span><br><span class="line"><span class="keyword">while</span>( ( buf = getchar() ) != EOF )&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个while循环可能永远不能退出。因为EOF是-1，所以getchar()返回值是int。当读到EOF时，先被先截断到char，再扩展到int类型于EOF比较。如果这个char是无符号的，那么这个EOF被截断再扩展后就不等于EOF了。。。</p>
<p>下面是个实验：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">signed</span> <span class="keyword">char</span> s_cha = <span class="number">0xFF</span>;      <span class="comment">//EOF, -1</span></span><br><span class="line">    <span class="keyword">int</span> s_integer = s_cha;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"int converted form signed char: "</span> &lt;&lt; s_integer &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> us_cha = <span class="number">0xFF</span>;</span><br><span class="line">    s_integer = us_cha;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"int converted form unsigned char: "</span> &lt;&lt; s_integer &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//      int converted form signed char: -1</span></span><br><span class="line"><span class="comment">//      int converted form unsigned char: 255</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//所以短字节数向长字节数扩展时，务必注意是否带符号！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//再看这个例子：同样是上面的两个char的0xFF</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> us_integer = s_cha;    <span class="comment">//这里改成无符号int</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"unsigned int converted form signed char: "</span> &lt;&lt; us_integer &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    us_integer = us_cha;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"unsigned int converted form unsigned char: "</span> &lt;&lt; s_integer &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//      unsigned int converted form signed char: 4294967295</span></span><br><span class="line"><span class="comment">//      unsigned int converted form unsigned char: 255</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//可见，在扩展时接收的变量是否有符号是不影响的，只不过解释的方式不同而已。</span></span><br><span class="line">    <span class="comment">//注释：4294967295就是0xFFFFFFFF，解释成普通int就是-1</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h4 id="有关指针"><a href="#有关指针" class="headerlink" title="有关指针"></a>有关指针</h4><p>_</p>
<h5 id="指针的申明"><a href="#指针的申明" class="headerlink" title="指针的申明"></a>指针的申明</h5><p>对于<code>int * a;</code>，应该理解为：a变量「解引用」后是int。（这对于理解函数指针等复杂指针很有帮助）<br>所以<code>*</code>号是跟着a一边的，而不是int一边的。（例子：<code>int * a, b, c;</code> 只有a是指针，另两个都是int）</p>
<h5 id="「数组名」就是「指针常量」吗？"><a href="#「数组名」就是「指针常量」吗？" class="headerlink" title="「数组名」就是「指针常量」吗？"></a>「数组名」就是「指针常量」吗？</h5><p>不是。数组名在参与表达式运算以及函数传参时，被<code>隐式转化</code>成指针常量。一个好的例子是<code>sizeof()</code>运算符应用于数组名时，返回的是整个数组的长度。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个奇怪的例子：</span></span><br><span class="line"><span class="comment">//--------------------</span></span><br><span class="line"><span class="comment">//文件a.c中：</span></span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//文件b.c中：</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">int</span> * a;</span><br><span class="line"><span class="comment">//然后在b.c中执行：会发生什么？</span></span><br><span class="line">    a[<span class="number">3</span>] = <span class="number">1</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//--------------------</span></span><br><span class="line"><span class="comment">//C语言解析`a[3]`时，采用`*(a+3)`计算。b.c文件编译时，认为a是指针，于是去a地址取出指针的值。在链接时，a在a.c中定义的是数组名，a不是指针`变量`（间接取值），常量在编译期直接替换为「直接量」(字面值)。a的地址就是a[0]的地址，于是b.c取到的是a[0]的值，而不是数组的起始地址！最后，*(a+3)计算出来的，是一个由a[0]值决定的未知位置。</span></span><br></pre></td></tr></table></figure></p>
<h4 id="链接属性"><a href="#链接属性" class="headerlink" title="链接属性"></a>链接属性</h4><p><code>extern</code>—链接时，当做同一个实体。<br><code>static</code>—仅在本文件有效。</p>
<h4 id="存储属性"><a href="#存储属性" class="headerlink" title="存储属性"></a>存储属性</h4><p><code>register</code>—强制要求这个变量存在寄存器内<br><code>static</code>—强制要求这个变量存在静态内存区</p>
<h4 id="再看「-x」与「x-」"><a href="#再看「-x」与「x-」" class="headerlink" title="再看「++x」与「x++」"></a>再看「++x」与「x++」</h4><ol>
<li>自增运算符，参与运算的，是x值的拷贝，而不是x本身。所以<code>a++ = 1</code>是非法的，a++是一个临时常量，不可以当「左值」。</li>
<li>在同一句语句中，用了自增就别再用这个变量了。<code>a + --a</code>这样的语句的结果是取决于编译器的。虽然自增优先级高，的确会先自增，但是无法确定左边那个a是在自增前取值还是自增后取值。（另：操作符的优先级，仅对相邻的操作符起作用。不相邻的取决于编译器）</li>
</ol>
<hr>
<h4 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h4><p>_</p>
<h5 id="预定义符号"><a href="#预定义符号" class="headerlink" title="预定义符号"></a>预定义符号</h5><p><strong>FILE</strong>—文件名<br><strong>LINE</strong>—当前行数<br><strong>DATE</strong>—编译日期<br><strong>TIME</strong>—编译时间</p>
<h5 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h5><p><code>#define SYMBOL value</code><br>[注]NAME中间不可以有空格，value中间不能有回车，如果要，请在回车前加<code>\</code>转义</p>
<p>带参数：<br><code>#define SYMBOL(parameter_list) stuff</code><br>[注]</p>
<ol>
<li>有点类似于「内联函数」但也有区别，1. 这里的参数没有指定类型。2. 这里甚至可以用类型作为参数。（预处理是文本替换，它不管你的文本是什么含义）</li>
<li>后面内容如果有数值计算的，请注意它是文本替换，并没有计算出结果。文本替换后小心由于运算符优先级带来的bug，请加括号。</li>
<li>#define里面不可以有#if，反之可以</li>
<li>#define里面可以有定义好的符号，但是不可以递归</li>
<li>#undef 可以取消一个符号的定义</li>
</ol>
<p>[另]在stuff中：<br><code>#argument</code>会被替换成<code>&quot;argument&quot;</code>就是给它加对引号<br><code>##</code>会把它两边的预定义变量连在一起（为什么需要这个？因为直接连在一起就认不出来了嘛。。。）</p>
<p>cocos2d-x示例：<br>这个宏函数功能是生成一个成员变量，并配套一套存取器方法。<br><code>注意两个##号的使用</code></p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">define <span class="title">CC_SYNTHESIZE</span>(<span class="params">varType, varName, funcName</span>)\</span><br><span class="line"><span class="keyword">protected</span>: varType varName</span>;\</span><br><span class="line"><span class="keyword">public</span>: varType <span class="keyword">get</span><span class="meta">##funcName(void) const &#123; return varName;&#125;\</span></span><br><span class="line"><span class="keyword">public</span>: <span class="keyword">void</span> <span class="keyword">set</span><span class="meta">##fucnName(varType newValue) &#123;varName = newValue;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如何使用：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">foo</span>&#123;</span><br><span class="line">    CC_SYNTHESIZE(<span class="keyword">int</span>, _innerMember, innerMember);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这样就可以有一个_innerMember成员，一对getinnerMember(),setinnerMember()，成员函数了。</p>
<h5 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h5><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span>  constant-expression</span></span><br><span class="line">    statement</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>常量表达式是「真」，就插入中间的表达式，否则整段删除。<br>[注]</p>
<ol>
<li>也可以由<code>#elif</code>、<code>#else</code>逻辑</li>
<li><code>#ifndef SYMBOL</code>就是<code>#if !defined(SYMBOL)</code></li>
</ol>
<p>例子：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//example_about_CONDITIONAL_COMPILATION</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NO_DEBUG 0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> NO_DEBUG</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> PRINT(x)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> OK</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> PRINT(x)  \</span><br><span class="line">            cout &lt;&lt; #x<span class="string">" = "</span> &lt;&lt; x \</span><br><span class="line">            &lt;&lt; <span class="string">"    line: "</span> &lt;&lt; __LINE__ &lt;&lt; endl</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> OK \</span><br><span class="line">            cout &lt;&lt; <span class="string">"OK!    line: "</span> &lt;&lt; __LINE__ &lt;&lt; endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>加上这段以后，在代码中可以用<code>PRINT(变量)</code>和<code>OK</code>调试，在不需要时，把<code>NO_DEBUG</code>设为1就没有这些调试信息了。</p>
<h5 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h5><p>防止文件重复包含：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _HEADFILENEME_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _HEADFILENEME_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//你的头文件，名字和上面保持一致：headfileneme.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<hr>
<h4 id="关于I-O"><a href="#关于I-O" class="headerlink" title="关于I/O"></a>关于I/O</h4><p>ANSI C的io是比较高层的，在各个操作系统中会调用不同的底层io函数。大多数f开头的io函数都是ANSI C的标准io函数，通用。</p>
<h5 id="关于缓冲区"><a href="#关于缓冲区" class="headerlink" title="关于缓冲区"></a>关于缓冲区</h5><p>标准io库函数在执行io操作时，默认会申请一片内存作为缓冲区。缓冲方式有两种：<code>全缓冲</code>和<code>行缓冲</code>。<br>「读操作」<br>对于全缓冲，每次读整个缓冲区的大小的文件，行缓冲读到换行符为止。然后根据程序需求从缓冲区取数据，通过指针便宜读取而不改变缓冲区的内容。当指针移到缓冲区末尾时，清空缓冲区，重新去文件中取一片数据回来。<br>「写操作」<br>类似，写满了，再真正写入文件。提前写入，请<code>fflush()</code></p>
<p>[另]<br>缓冲区的指定<br><code>setvbuf()</code>函数可以手动指定一个io文件的「缓冲方式」以及「缓冲区位置」。</p>
<h5 id="二进制IO与字符IO区别"><a href="#二进制IO与字符IO区别" class="headerlink" title="二进制IO与字符IO区别"></a>二进制IO与字符IO区别</h5><ol>
<li>字符io要负责<code>数字</code>「补码」与「ASCII码」的转换</li>
<li>字符io能识别换行符<br>所以二进制io更快</li>
</ol>
<hr>
<h4 id="有用的库函数"><a href="#有用的库函数" class="headerlink" title="有用的库函数"></a>有用的库函数</h4><p><code>clock()</code>—函数执行消耗的cpu时间<br><code>qsort()</code>—高效的排序<br><code>signal.h</code>—信号处理（这个竟然是标准库）</p>
<hr>
<p>最后附上去年刚学C语言时的笔记作为备份（可能有错仅作备份）</p>
<h4 id="c语言Tips："><a href="#c语言Tips：" class="headerlink" title="c语言Tips："></a>c语言Tips：</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">##1. 关于printf。</span></span><br><span class="line">* 可以有返回值，为打印计数（包括空格）。用于检查非屏幕打印</span><br><span class="line">* 打印内容过长时，可在两行间，暂时用一对双引号断开。</span><br><span class="line">* 当要求输出”/n”时，将强制清空缓冲区，在屏幕输出</span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment">##2. 关于scanf。</span></span><br><span class="line">* 默认时，遇到［空格］、［tab］或［换行符］停止当此输入</span><br><span class="line">* 可用数字表示最大宽度。</span><br><span class="line">	如：%<span class="number">10</span>S，代表最多扫描<span class="number">10</span>个字符就结束。但如果中间遇到空格等还是要提前结束</span><br><span class="line">* 返回值是成功读入的项目计数。</span><br><span class="line">* 输入`control + z`，即为EOF, 值为<span class="bullet">-1</span></span><br><span class="line">* 当读入格式与要求格式不同时，打断。</span><br><span class="line">	如：要求%d，而输入为字符，则返回空。且下次扫描时，仍然从该字符开始。</span><br><span class="line">* **重要！！-----关于缓冲区**</span><br><span class="line">    当这些扫描输入的函数需要输入时，它们首先去检查缓冲区，如果有内容，就直接取。如果没有，则中断，要求用户输入。此事，无论用户输入多少内容，当且仅当用户输入“回车”时，才会一次性把刚刚输入的内容push进缓冲区。（此时是系统调用，程序处于“阻塞”状态）</span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##3. “逗号”运算符</span></span><br><span class="line"><span class="number">1.</span>  在for语句中，使用逗号运算符隔开两句，可一次进行两次动作。</span><br><span class="line">    例如：`for(i=<span class="number">1</span>, j=<span class="number">1</span>; i&lt;=<span class="number">10</span>; j++);`</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>  逗号运算得最终取值为右边得表达式。 注：附值符号返回值为左值。</span><br><span class="line">如：`i = ( <span class="number">40</span>, <span class="number">50</span>)`; 此时i被附值为<span class="number">50</span> 。</span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line">		</span><br><span class="line"><span class="comment">##4. 函数式宏定义</span></span><br><span class="line">范例：</span><br><span class="line"></span><br><span class="line">	<span class="comment">#define HTON(host) \</span></span><br><span class="line">	(host &amp; <span class="number">0xff000000</span>) &gt;&gt; <span class="number">24</span> | (host &amp; <span class="number">0x00ff0000</span>) &gt;&gt; <span class="number">8</span> | \</span><br><span class="line">	(host &amp; <span class="number">0x0000ff00</span>) &lt;&lt; <span class="number">8</span> | (host &amp; <span class="number">0x000000ff</span>) &lt;&lt; <span class="number">24</span></span><br><span class="line"></span><br><span class="line">关键点：<span class="number">1.</span> 最后的反斜杠是续行符，注意反斜杠后面不能加任何内容，只能立即回车</span><br><span class="line">		<span class="number">2.</span> HTON(host) 中间不能有空格（宏定义原样替换嘛）</span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##5. 关于getchar</span></span><br><span class="line">* 从用户输入回车的那一刻起，每次抓取一个字符，什么都抓！</span><br><span class="line">**包括[回车][tab]等！（注：scanf和gets会忽略回车等）**</span><br><span class="line">* 可以被用作清空缓冲区（因为什么都抓嘛）</span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##6. 关于fgets(point, maxsize, stdin)</span></span><br><span class="line">* 每次抓一整行字符，不包含末尾的回车</span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##7. 关于char类型</span></span><br><span class="line">* 占<span class="number">1</span>个字节</span><br><span class="line">* 可以等同与int操作，例如两个字符可以直接比大小，不用直接转为ASCII码</span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##9. 未定义变量的默认值：</span></span><br><span class="line">堆栈内变量默认值全为`cc`，静态变量、全局变量默认值全`cd`</span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##10.理解++i 和 i++</span></span><br><span class="line">亲，不要去考虑优先级。即使++i的优先级是最高的，也不会每次都最优先运行。</span><br><span class="line">请看范例：`int j = <span class="number">1</span>;`，`i = j - ++j;`，运算结束后，i=<span class="bullet">-1</span>，说明左++并没有在整个式子中最优先，仅表示在使用后一个j时，先把j增<span class="number">1</span>，而已。</span><br><span class="line"></span><br><span class="line">同样的，`i = j++ -j;`,结果i也等于－<span class="number">1</span>。说明并不是在整个式子结束以后再j增<span class="number">1</span>，其实是在把j放入式子以后立马给j增<span class="number">1</span>。</span><br><span class="line"></span><br><span class="line">&gt; **从硬件角度考虑，怎么解释呢？有待研究。**</span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##11. main函数的参数</span></span><br><span class="line">main函数的规范申明：`int main(int argc, char const *argv[])`，其中：</span><br><span class="line"></span><br><span class="line">* argv[o]指向该文件的绝对路径</span><br><span class="line">* argv[<span class="number">1</span>]、argv[<span class="number">2</span>]....分别是终端中输入的参数，string * 类型，以“空格”分开。</span><br><span class="line">	例： test.exe hello world   其中，hello是argv[<span class="number">1</span>]，world是argv[<span class="number">2</span>]</span><br><span class="line">* argc参数计数器</span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##12. 关于数组在函数中的参数传递</span></span><br><span class="line">数组在参数传递中，默认传递的就是指针（地址），并`<span class="number">100</span>%丢失`数组长度信息。</span><br><span class="line"></span><br><span class="line">例如：`func(int a[])`等价于`func(int * a)`等价于`func(int a[<span class="number">10</span>])`</span><br><span class="line"></span><br><span class="line">值得注意的是：`int a[<span class="number">10</span>]; sizeof(a);` 得<span class="number">40</span></span><br><span class="line">而如果a作为参数传递到函数中时，`sizeof(a)`;得<span class="number">4</span>。 （int的长度）（说明长度信息丢失）</span><br><span class="line"></span><br><span class="line">另外，二维和三维数组定义为形参数时，除第一维外都需显示指定，如`func(a[][<span class="number">10</span>])`</span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##13. 指向数组的指针</span></span><br><span class="line">定义： `int (* name)[MAX]`，其中MAX为指向的数组长度。</span><br><span class="line">如何使用：</span><br><span class="line"></span><br><span class="line">* `name++`相当于二维数组跳到下一行。</span><br><span class="line">* `name[<span class="number">1</span>]`指向第二行的首元素，类型为**`int *`**！！！即指向int的指针。</span><br><span class="line"></span><br><span class="line">注意！ `int *a[<span class="number">10</span>]`指针的数组。 `int (*a)[<span class="number">10</span>]`指向数组的指针。</span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##14. 指向指针的指针</span></span><br><span class="line">定义：`int * (*name)`</span><br><span class="line">如何使用：一般在需要在调用函数后**`返回指针`**时定义在形参中，调用该函数时，传入指针的地址即可。</span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##15. 关于static</span></span><br><span class="line">用法一：</span><br><span class="line"></span><br><span class="line">* 作用于**函数** 和**全局变量**时，表示该全局变量变量、函数仅对**本文件**有效</span><br><span class="line"></span><br><span class="line">用法二：</span><br><span class="line"></span><br><span class="line">* 作用于**局部变量**时，表示该局部变量在函数调用结束后仍然不销毁。</span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##16. 多文件的全局变量申明</span></span><br><span class="line"></span><br><span class="line">由于include的特性，全局变量的定义在被include两次后会报错（重复定义）。需要把定义改为**申明**。</span><br><span class="line">用法：在**头文件**中，`extern int name`。 在**主文件**中：`int name = <span class="number">1</span>`即可。</span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##17. 关于malloc</span></span><br><span class="line"></span><br><span class="line">malloc的空间在`堆`内，系统不会自动释放。局部变量在`栈`，调用完函数后自动销毁。全局变量在`系统常量区`。</span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##18. 移位操作</span></span><br><span class="line">注意，移位操作**`不考虑`**“小端”，认为二进制就是顺着的！</span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##19. 函数指针</span></span><br><span class="line">**定义**为：指向`特定参数、特定返回值`的一类函数的指针。定义的语法比较奇怪，参考：&lt;http://stackoverflow.com/questions/<span class="number">4295432</span>/typedef-function-pointer<span class="string">&gt;</span><br><span class="line"></span><br><span class="line">**存在的价值：** 可以在定义函数时，把特定的功能分离出去，`把函数作为参数`！</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">##20. 关于定义const类型</span><br><span class="line">**关键点1：**加了const的类型其实也是变量，只是编译器会保护这个值不被更改。</span><br><span class="line">**关键点2：**传入普通的变量，编译器会自动转化为const的，不会警告。</span><br><span class="line">**关键点3：**建议用const替代define定义常量， 因为const拥有变量类型，可以调整</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">##21. C的文件函数特点</span><br><span class="line">**关键点1：**C的文件函数是对系统(linux/windows)的文件函数的封装，增加了用户级缓冲区。通过缓冲区，一次性读取一个文件块，减少实际的系统调用／读取文件的次数。</span><br><span class="line">**关键点2：**C的文件函数拥有ASCII模式，这个模式可以辨识字符流中的回车(win-\r\n, linux-\r)，实现按行读取。而系统的底层文件函数只知道二进制数据流。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##22. struct的大小内存对齐</span><br><span class="line">32位以4B为单位对齐，因为内存里一次读取四个字节，如果不对齐，读取一个数据时可能要多次读取内存，降低效率。</span></span><br></pre></td></tr></table></figure>
<h4 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h4><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="meta">###1. 指定内存空间的初始化</span></span><br><span class="line">`<span class="keyword">void</span> * memset ( <span class="keyword">void</span> * ptr, <span class="keyword">int</span> value, size_t num );`</span><br><span class="line"></span><br><span class="line">- 需要include &lt;<span class="keyword">string</span>.h&gt;</span><br><span class="line">- 填充方式：以<span class="keyword">int</span>型填充，每次以`<span class="number">1</span>个字节`的补码，所以只能填充<span class="number">0</span>，或－<span class="number">1</span>（补码为全<span class="number">0</span>和全<span class="number">1</span>），否则以其他类型读取时会出问题。</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="meta">###2. 一种对整数数量级的试探技巧</span></span><br><span class="line">`<span class="keyword">while</span>(w/i) i*=<span class="number">10</span>;` 退出时，i即比最高位多<span class="number">1.</span></span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="meta">###3. 简易随机数生成</span></span><br><span class="line">`#include &lt;time.h&gt;`</span><br><span class="line">`#include &lt;stdlib.h&gt;`</span><br><span class="line">`srand(time(<span class="number">0</span>))`</span><br><span class="line">`rand()%<span class="number">100</span>`  其中<span class="number">100</span>是范围上限，<span class="number">0</span>是默认下限。</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="meta">###4. 想给int赋一个默认的最小值？</span></span><br><span class="line">`<span class="number">0x8000</span> <span class="number">0000</span>` （补码）</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="meta">###5. 怎么取一个数字得某几位？</span></span><br><span class="line">方法一：`按位“与”`（掩码）！</span><br><span class="line">方法二：用更小号的指针（<span class="keyword">char</span> *玩<span class="keyword">int</span>）操作它！`注意小端机的内存中的存放逆序！`</span><br><span class="line"></span><br><span class="line"><span class="meta">###6. c语言库中的万能排序`qsort`</span></span><br><span class="line">详参：&lt;http:<span class="comment">//en.cppreference.com/w/c/algorithm/qsort&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">###7. **`sprintf`** ,**`sscanf`**格式化输入/输出去不同的目标（文件、字符串）</span></span><br><span class="line"></span><br><span class="line"><span class="meta">###8. malloc的替代？`calloc`分配空间并初始化为**0**</span></span><br><span class="line">参考：&lt;http:<span class="comment">//en.cppreference.com/w/c/memory/calloc&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">###9. 整型和字符串转换</span></span><br><span class="line">`itoa`，`atoi`  ASCII to Integer</span><br><span class="line"></span><br><span class="line"><span class="meta">###10. 比较字符串的前n个字符，strncmp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">###11.无限从屏幕输入</span></span><br><span class="line"></span><br><span class="line">`<span class="keyword">while</span>(memset(send_buf,<span class="number">0</span>,<span class="number">1024</span>),fgets(send_buf,<span class="number">1024</span>,<span class="keyword">stdin</span>)!=NULL)`</span><br><span class="line"></span><br><span class="line"><span class="meta">###12.读取整个文件</span></span><br><span class="line"></span><br><span class="line">`<span class="keyword">while</span>(memset(buff, <span class="number">0</span>, <span class="number">4096</span>), fread(buff,<span class="number">1</span>,<span class="number">4096</span>,fp)&gt;<span class="number">0</span>)`</span><br><span class="line"></span><br><span class="line">`<span class="keyword">while</span>(memset(buff, <span class="number">0</span>, <span class="number">4096</span>), fgets(buff, <span class="number">1024</span>,fp) != NULL)`</span><br><span class="line"></span><br><span class="line"><span class="meta">###13.精确的sleep()－－－－usleep()</span></span><br><span class="line"></span><br><span class="line"><span class="meta">###14.计时器</span></span><br><span class="line">- alarm(<span class="number">3</span>)   三秒后向自己发SIGALRM类型<span class="keyword">signal</span></span><br><span class="line">- setitimer()  函数比较复杂，高级计时器，也向自己发送SIGALRM类型<span class="keyword">signal</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">如何动态申请二维数组</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> *argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">// 3 * 4</span></span><br><span class="line">    <span class="keyword">int</span> ** arr = (<span class="keyword">int</span> **)<span class="built_in">malloc</span>(<span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span> *));</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i != <span class="number">3</span>; ++i)&#123;</span><br><span class="line">        arr[i] = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="number">4</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">二维数组传参技巧</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> * 把数组封装到结构体中，用m和n指定维度</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _Array &#123;</span><br><span class="line">    <span class="keyword">int</span> A_[M][N];</span><br><span class="line">    <span class="keyword">int</span> m_;</span><br><span class="line">    <span class="keyword">int</span> n_;</span><br><span class="line">&#125;Array;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(Array *arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i != arr-&gt;m_; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j != arr-&gt;n_; ++j)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>, arr-&gt;A_[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> *argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    Array arr;</span><br><span class="line">    arr.m_ = <span class="number">3</span>;</span><br><span class="line">    arr.n_ = <span class="number">4</span>;</span><br><span class="line">    print(&amp;arr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></article></div></section><footer><div class="paginator"><a href="/2015/02/13/小规模C++语法笔记/" class="prev">PRVE</a><a href="/2015/02/05/配置一台真正的服务器/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2016 <a href="http://Rocklu.me">Rock Lu</a>, unless otherwise noted.</p></div></footer><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script></body></html>