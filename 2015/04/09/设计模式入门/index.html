<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 设计模式 · Rock's personal notebook</title><meta name="description" content="设计模式 - Rock Lu"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/u/1565858217" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/rulerstorm" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li><li class="nav-list-item"><a href="/impress/index.html" target="_self" class="nav-list-link">TEST</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">设计模式</h1><div class="post-time">Apr 9, 2015</div><div class="post-content"><p>有幸听到侯捷老师的面授，不敢懈怠。可惜只有短短8次课，只能做个入门。<br>课件链接：<a style="text-decoration:none; color:blue;" href="http://pan.baidu.com/s/1o6625ei" target="_blank" rel="external">DesignPatterns_2014.pdf</a><br>其中，正红色文字是我自己加的注释。</p>
<a id="more"></a>
<h4 id="什么是设计模式？"><a href="#什么是设计模式？" class="headerlink" title="什么是设计模式？"></a>什么是设计模式？</h4><p>设计模式，是从既有开发经验中抽取出来的，对于既有问题的解决方法的范式。<br>通常所说的设计模式，是指GOF(gane of four)四个人编写的《Design Patterns》中提到的23个设计模式。<br>设计模式的实现，需要编程语言支持<code>面向对象</code>的功能。<br>[另外]对于设计模式后面小括号中的数字，通常指这本书的页码。<br>[经典书]</p>
<ol>
<li>Design Patterns – GOF</li>
<li>Refactoring – Martin Fowler</li>
<li>Refactoring to Patterns – Josiua Kerievsky</li>
<li>Modern C++ Design – Andrel Alexandrescu</li>
<li>Small Memory Software – James Nobles</li>
<li>More effective C++ – Scott Meyers</li>
</ol>
<hr>
<h4 id="Class之间的三种关系"><a href="#Class之间的三种关系" class="headerlink" title="Class之间的三种关系"></a>Class之间的三种关系</h4><p>_</p>
<h5 id="composition-复合"><a href="#composition-复合" class="headerlink" title="composition-复合"></a>composition-复合</h5><p>A持有B的实体，则AB的关系为复合。<br>[注意]两者的生命期完全相同</p>
<h5 id="Delegation-委托"><a href="#Delegation-委托" class="headerlink" title="Delegation-委托"></a>Delegation-委托</h5><p>A持有指向B的指针，则A是<code>委托者</code>，B是<code>受托者</code>或<code>代理</code>。即，A向B传递信息，委托这个任务给代理B处理。<br>[注意]两者生命周期不同<br>[例子]一个窗口（委托者），持有一个绘图类（受托者）的指针，把绘图的这部分任务委托给绘图类做。<code>那么为什么需要用指针而不是直接持有呢？</code>因为这个指向绘图类的指针，将来是可以指向任何一个该类的<code>子类</code>的，只要继承自该绘图类的子类，后期都是可以更换使用的！</p>
<h5 id="Inheritance-继承"><a href="#Inheritance-继承" class="headerlink" title="Inheritance-继承"></a>Inheritance-继承</h5><p>没啥说的。。。。</p>
<hr>
<h4 id="OOP开发的六大守则（课程只提两个）"><a href="#OOP开发的六大守则（课程只提两个）" class="headerlink" title="OOP开发的六大守则（课程只提两个）"></a>OOP开发的六大守则（课程只提两个）</h4><p>_</p>
<h5 id="OCP-open-closed-principle-开放封闭守则"><a href="#OCP-open-closed-principle-开放封闭守则" class="headerlink" title="OCP (open-closed principle, 开放封闭守则)"></a>OCP (open-closed principle, 开放封闭守则)</h5><p>对扩充开放，对修改封闭。<br>意思是，class写完以后，要能够有灵活度以后能加新的功能，但是不应该需要修改原来写好的代码。<br>[例子]链接库、jar<br>[关键]抽象化</p>
<h5 id="LSP-Liskov-Substitution-principle-里氏替代原则"><a href="#LSP-Liskov-Substitution-principle-里氏替代原则" class="headerlink" title="LSP (Liskov Substitution principle, 里氏替代原则)"></a>LSP (Liskov Substitution principle, 里氏替代原则)</h5><p>父类能用的场合，子类一定能用。（子类 <code>is a</code> 父类）<br>用在什么地方呢？就是有时候考虑要借用一个写好类的功能时，要继承呢？还是要复合呢？的时候考虑这个准则来判定要不要使用继承。</p>
<hr>
<h4 id="关于类图"><a href="#关于类图" class="headerlink" title="关于类图"></a>关于类图</h4><p>类图有多种流派，这里解释UML风格的类图</p>
<h5 id="类表示"><a href="#类表示" class="headerlink" title="类表示"></a>类表示</h5><p>方框，第一行类名，第二行类数据，第三行类方法。<br>不必写全，只写需要描述的部分。<br>如果没有类数据或类方法，空白即可。<br>如果是<code>斜体</code>的函数，是虚函数<br>如果有<code>下划线</code>，表示static成员</p>
<h5 id="类关系"><a href="#类关系" class="headerlink" title="类关系"></a>类关系</h5><p><code>菱形</code>标记代表持有，实心是持有实体（复合），空心是持有指针（委托）<br><code>剪头</code>指向一个类，代表继承自这个类<br><code>实线</code>拖出来的方块，代表对某个函数的伪代码片段</p>
<hr>
<h4 id="Template-Method"><a href="#Template-Method" class="headerlink" title="Template Method"></a>Template Method</h4><p>Define the skeleton of an algorithm in an operation, <code>deferring</code> some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm’s structure.</p>
<p>最常见的就是在设计application framework的时候，把大部分通用的流程写好，留出一些需要更改的部分，以<code>虚函数</code>的方式留在那里，俗称“孔”。然后开发者在使用这些类库的时候，只需要<code>重写</code>或<code>实现</code>这些孔，就能做到写很少代码作出一个完整的应用。<br>所谓template，就是类库里面的那种通用流程的函数，template函数里面会调用到孔函数。</p>
<p>[实现]某些个性化功能的函数写成virtual，让子类去实现覆盖<br>[另]framwork有很多种，appliation framwork是用来帮助创建apllication的framwork。好像废话。。。</p>
<hr>
<h4 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h4><p>Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.<br>[侯捷注]上面英文的定义有问题，实际上，notify是一定的，update是可选的。<br>所谓one-to-many，one指被观察者，many指观察者。被观察者发生变化的时候，它有责任告诉所有观察者自己发生了变化，让观察者处理变化。有点像信息推送、报纸订阅。<br>[实现]</p>
<ul>
<li><strong>被观察者需要实现的功能</strong><ol>
<li>存放观察者的容器，如：vector。一般持有指向观察者的<code>指针</code>。</li>
<li>增加观察者。即让观察者注册，我需要知道你的变化。</li>
<li>删除观察者。即，退订</li>
<li>通知观察者。push message。这里要调用观察者的某个方法。这个方法是协定好的。</li>
<li>一个flag，标记是否发生过变化。changed</li>
</ol>
</li>
<li><strong>观察者需要实现：</strong><ol>
<li>实现由被观察者调用的那个方法，对被观察者的变化进行处理。这个函数通常会把指向被观察者的指针当作一个函数传递过来，有时还会传递一个hint，告诉你我具体修改了哪些数据。<br>[使用]<br>一般库函数会写好一个观察者类一个被观察者类，只要从他们继承，然后实现通知方法，就能实现功能。</li>
</ol>
</li>
</ul>
<hr>
<h4 id="Adapter"><a href="#Adapter" class="headerlink" title="Adapter"></a>Adapter</h4><p>Convert the interface of a class into another interface clients expect. Adapter lets classes work together that couldn’t otherwise because of incompatible interfaces.<br>望文生义，适配器。就是用一些浅层的包装，让以前写好的类能够用到新的地方。<br>从实现方式来说，有Class Adapter（用继承实现）和Object Adapter（用复合或委托实现）<br>[注]那么，我们要继承还是不要继承呢？请参考LSP准则<br>从功能来说，有Container Adapters, Function Adapters, Iterator Adapters。</p>
<p>[名词注解]<br>adapter—-适配器<br>adaptee—-原来的对象，被适配的对象<br>adaptable—-可以被适配器适配的能力</p>
<h5 id="Container-Adapters"><a href="#Container-Adapters" class="headerlink" title="Container Adapters"></a>Container Adapters</h5><p>例如把dequeue改成一个stack这种简单的应用<br>实现上，可以是继承，也可以是复合。主要是调用原来容器的方法，适配新的方法。</p>
<h5 id="Funcion-Adapters"><a href="#Funcion-Adapters" class="headerlink" title="Funcion Adapters"></a>Funcion Adapters</h5><p>重用以前写好的函数，通过绑定某些参数（固定参数的值），或者更换参数的顺序，使其能用于现在的应用。<br>问题在于，函数的实参不是在调用的时候才确定的吗？为什么可以事先绑定呢？<br>答案是这样的：函数适配器其实不是一个函数，也不是一个函数指针。它是一个class，function object，这种类，由于重载了<code>()</code>小括号运算符，所以<code>表现得像一个函数</code>。是一个class呢，就能够把预先输入的参数，作为class的data储存起来，当需要调用的时候，就是除法这个小括号重载函数的时候，再把这个预先输入的（绑定的）值拿出来，放到那个需要适配的函数的实参里面去。</p>
<p>思路是比较简单的，实现起来还是蛮复杂的。复杂度主要来自于这个适配器是范型的，对于类型的判断和传递挺费劲。<br>[实现]<br>对于适配器来说，我需要最后表现为一个函数，那么就像前面提到的，我需要是一个function object，我要实现：1.持有适配的adaptee函数，2.持有需要绑定的具体的参数，3.一个小括号的重载来使用绑定的参数来调用adaptee函数。</p>
<p>但是问题来了，我事先不知道你这个adaptee的参数类型，我怎么知道我要绑定的参数的类型呢？于是adaptee必须要有让adapter查询参数类型的接口。C++STL的解决方案是让所有想adaptable的class全都继承一种很奇怪的struct（如：<code>unary_fuction</code>, <code>binary_fuction</code>），这种struct呢，里面只有几个typedef，它自己本身也是范型的。这种struct干什么呢，就是让需要adaptable的class呢，在继承它的时候，就把自己的参数啊、返回值这种类型全都交给它，然后它有几个typedef把这几个类型别名为一组<code>标准的</code>名字（<code>first_argument_type</code>），将来供adapter询问（查询）。于是，adapter只要进入adaptee的命名空间，就可以访问到这个adaptee的父类，就是那个怪怪的struct，然后用那个标准的名字就可以知道adaptee的参数类型啊、返回值啊之类的了。[另]得到的这个类型，可以直接用哦，像什么加个小括号就是构造函数可以构造这个类的实例啊之类的。</p>
<p>最后呢，这个adapter有可能并不是最终产品啊，或许我们需要再将其适配，所以，它也需要adaptable，于是，它也要继承那个怪怪的struct。</p>
<p>[注意]对于范型的function object来说，func<type>()是它的实例，func<type>是它的类型，在形式上还是比较迷惑的。表老把它想成函数指针了，人家是一种class。</type></type></p>
<hr>
<h4 id="Composite"><a href="#Composite" class="headerlink" title="Composite"></a>Composite</h4><p>Compose objects into tree structures to represent part-whole hierarchies. Composite lets clients treat individual objects and compositions of objects <code>uniformly</code>.<br>复合设计模式的精髓，在于组成树形结构的时候，以<code>一致的方式</code>对待单一物件和复合物件。<br>[注释]<br>复合物件，指的是单一物件的容器，例如文件夹<br>单一物件，即文件。<br>所谓树形结构，即文件夹内既可以放文件，也可以放文件夹。<br>一致的方式，就是在操作文件夹时，用同一组函数（方法）对待文件夹和普通文件。但是同样的函数，对于单一物件，应该可以直接得到返回值，而对于复合物件，就可能是递归的形式。</p>
<p>[例子]<br>File system<br>Windowing system – 窗体内嵌套窗体，也可以增加物件<br>Command – 命令中嵌套命令，也有参数</p>
<p>[实现]<br>对于<code>一视同仁</code>的阐释，又两个方面：<br>首先 ，复合物件里面必须要有容器。容器必须既可以装复合物件又可以装单一物件。<br>其次 ，复合物件和单一物件必须要有相同的API。</p>
<p>那么解决方法显而易见：让它们<code>共同继承</code>一个父类。然后复合物件的容器可以存放<code>指向父类的指针</code>。再者，两者公共的API可以在父类中定义<code>虚方法</code>，由两个子类各自去实现自己的版本。</p>
<p>[另外]这里有个常见的小技巧，对于个别物件不应该定义的方法（例如增加子物件），也抽离出来，在上层父类中定义，并把这个方法的内容写成<code>抛出异常</code>。然后，让复合物件重写这个方法。于是，如果个别物件调用了这个方法自然抛出异常。</p>
<hr>
<h4 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h4><p>Provide a way to access the elements of an aggregate object sequentially without exposing its underlying representation.<br>[注释]aggregate：容器，即container<br>迭代器模式，专门用在对容器的遍历。希望把容器的构造抽象，提供给外界<code>统一的接口</code>，遍历容器。<br>C++的迭代器，是一种行为像指针一样的class。</p>
<p>[实现]<br>首先，对于每一种容器，只有它自己才直到要怎么去遍历自己。于是，每个容器都应该定义自己的迭代器。</p>
<p>其次，对于一个实际的容器，这个用于遍历的“指针”，对于不同的访问者来说，不应该是唯一的、公用的，而应该是给每个访问者创建一个，你遍历你的，他遍历它的。于是，迭代器不应该写死在容器里，也不应该让容器持有指向迭代器的指针（因为数量是未知的）。那怎么办呢？给每一种容器，特别定义一个专属的迭代器class。Java中，当访问者需要一个迭代器时，由容器为其创造一个。而在C++中，在容器的命名空间中的typedef提供了迭代器的类型名称，由用户手动创建。大同小异。</p>
<p>对于迭代器而言，为了表现得像一个指针，则需要重载应用于指针得操作符，对外提供统一得API。</p>
<hr>
<h4 id="内存管理-Memory-Pool"><a href="#内存管理-Memory-Pool" class="headerlink" title="内存管理(Memory Pool)"></a>内存管理(Memory Pool)</h4><p>Memory Pool并不属于GOF的23种设计模式之列，但是也非常重要。</p>
<h5 id="背景知识－内存分配"><a href="#背景知识－内存分配" class="headerlink" title="背景知识－内存分配"></a>背景知识－内存分配</h5><p>[调用的层次关系：]<br><code>Applications</code> -&gt; <code>C++Library</code>(Stl,Boost) -&gt; <code>C++Primitives</code>(new) -&gt; <code>CRT</code>(c runtime) -&gt; <code>OS api</code>(HeapAlloc)</p>
<p>[内存管理实现（bookkeeping）]<br>CRT并没有像操作系统那样，对分配出去的内存用专门的数据结构记录管理。那么CRT怎么在free的时候，知道这个指针指向的地址，当初分配了多大空间给他呢？答案是在分配出去指针前面藏一个<code>cookie</code>，大小一般是4B。于是在free的时候，往前面看下cookie，就知道应该去释放多大的内存了。<br>[注释]忘记在哪里看到的cookie的来源，可能是西方什么故事的典故，主要意思是：小孩子来我家里玩，然后走的时候我把我自己做的cookie给她们带回去吃，每个小孩都给一种不一样的cookie。然后走了就走了，我也不去记住每个小孩的样子。但是以后每当再有小孩来的话，只要他带着我当时给他的cookie，我就知道他曾经来过，也知道他是谁啦～</p>
<h5 id="背景知识－C-中的new操作符"><a href="#背景知识－C-中的new操作符" class="headerlink" title="背景知识－C++中的new操作符"></a>背景知识－C++中的new操作符</h5><p>在C++中，new操作会被编译器翻译为三个动作：（以new className()为例）</p>
<ol>
<li>调用<code>::operator new()</code>分配一块内存。（参数是sizeof(className)）</li>
<li>把返回的指针<code>static_cast</code>至className类型</li>
<li>调用className的<code>构造函数</code><br>[另外]</li>
<li><code>::operator new()</code>这个全局函数是可以重载的，既可以是全局重载，也可以是在某个特定的class里面重载。</li>
<li>所有的内存分配操作，最后都会调用<code>malloc()</code></li>
<li>上面三个步骤如果失败，会抛出异常std::bad_alloc</li>
</ol>
<p>[关于<code>delete[]</code>中的方括号]<br>这叫<code>array new</code>、<code>array delete</code><br>加了方括号，会对地址内每个元素调用析构函数。不加，则仅对第一个元素调析构。<br>所以问题就是出在要析构的class上。对于持有指向heap指针的class，仅仅调用free释放这个class本身是不够的。对于这种类型的数组，delete的时候务必加方括号。一个好习惯是：new的时候有方括号，那么delete的时候也要有。</p>
<p>不加方括号也正确的例子：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</div><div class="line"><span class="keyword">delete</span>[] p;</div></pre></td></tr></table></figure></p>
<p>首先明确，delete和new类似，最后调用的是free()。对于由array new产生的p指向的空间，p前面的cookie会正确纪录分配给p的空间大小，是3份的int。所以无论这个delete加不加方括号，只要调用了free，free就会读取cookie，得到正确的空间大小，就能正确释放。</p>
<h5 id="Memory-Pool"><a href="#Memory-Pool" class="headerlink" title="Memory Pool"></a>Memory Pool</h5><p>[为啥要有memory pool]?</p>
<ol>
<li>对于小型class，4B的cookie代价太大</li>
<li>虽然malloc的实现各不相同，对于各种<code>不同的大小</code>的内存分配／归还，产生大量碎片。</li>
<li>系统调用的成本</li>
</ol>
<p>[memory pool思想]（focus on <code>SGI allocator</code>）<br>回想一下操作系统中的内存管理，其实思想有点类似于<code>分页存储</code>。<br>虽然用户提出的内存要求是不确定的，但是我们把内存以<code>固定大小的block</code>来配给内存。把外碎片变成内碎片。同时，由于大小是固定的，那我也不用cookie来纪录当时给了多大。这样可以解决前两个问题。<br>对于频繁的系统调用，请回想<code>printf,scanf</code>不管你要多少数据，我先读一大片进缓冲区，当你下次再要的时候，就不用再系统调用了。memory pool也是这个缓冲的思想，只不过pool是那种用完了还可以放进去循环利用的感觉，buffer就是一次性的。</p>
<p>[SGI allocator的实现概要]</p>
<ol>
<li>大于128B的请求，直接调用malloc。小于128B的，按照8、16、24…120、128这16种大小分配最合适的一块。</li>
<li>用一个数组，存放16个free_list（单链表）。这每个list，用来纪录对应的16种大小的block的分配情况。另外有两个指针纪录pool的开始和末尾。</li>
<li>分配策略如下：根据请求大小，可知应该去找哪个list要。先看list有没余量block，如果没有，就把pool全都那过来用。如果pool里面的空间都不够，就像系统请求40个当前block大小的内存，20个给list，20个给pool。</li>
<li>关于归还，客户把block还给list，然后就结束了。这个allocator并不归还内存给系统。</li>
<li>对于向系统请求失败的情况，分配器会看看有没有更大的list里面有空block，如果有的话可以借一块过来。<br><strong>注意：</strong>具体实现的细节很多，请看源码。</li>
</ol>
<p>[SGI allocator的缺陷]<br>内存不归还。。。其实是没法归还，因为单链表结构在反复使用后，已经无法判定block们是不是在一块连续的内存空间里面了。<br>[改进]例子：Loki small object allocator，参考书：<morden c++="" design=""><br>block们用<code>静态链表</code>连接，而且少量block就规划为一个chunk。静态链表解决了空间不连续的问题，而对比整个free_list，chunck较小，比较容易形成全空的情况，此时就可以回收归还给OS。<br>提一个细节，这种pool，即使归还内存，一般也会留存一个chunk在手里，以备客户需要。</morden></p>
<p>[应用]<br>其实，有的malloc实现中，也采用了pool的思想，但毕竟是通用的、对各种个样大小都要适合的服务。而allocator用的memory pool，则是对<code>固定大小</code>内存请求的优化（所以经常用在<code>容器</code>中）。</p>
<p>[嗯，那个。。。我不会写这个pool，可是我也想用这个allocator，可以嘛？]<br>可以的哦，亲～方法如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//方法一：重载全局::operator new()</span></div><div class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> alloc::allocate(size); <span class="comment">// get from free-list</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* p, <span class="keyword">size_t</span> size)</span> </span>&#123;</div><div class="line">    alloc::deallocate(p, size); <span class="comment">// return to free-list</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//方法二：重载某个class的operator new()</span></div><div class="line"><span class="comment">//注意这个class只有小于128B，才有意义</span></div><div class="line"><span class="keyword">class</span> MyClass&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> alloc::allocate(size); <span class="comment">// get from free-list</span></div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* p, <span class="keyword">size_t</span> size)</span> </span>&#123;</div><div class="line">        alloc::deallocate(p, size); <span class="comment">// return to free-list</span></div><div class="line">    &#125;</div><div class="line"><span class="comment">//其他成员</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<hr>
<h4 id="Factory-Method"><a href="#Factory-Method" class="headerlink" title="Factory Method"></a>Factory Method</h4><p>Define an interface for creating an object, but let subclasses decide which class to instantiate. Factory Method lets a class <code>defer</code> instantiation to subclasses.<br>又是defer！与Template Method相比，Factory Method延缓的是<code>实例化</code>的动作。主要的应用是在大型框架。大型框架的运作，需要预先对用户派生的子类进行操作。但是用户具体定义的类name预先是不可能知道的。所以这里必须进行抽象化延缓。<br>[注释]Factory Method中，method指的是一个用来创建子类的<code>虚函数</code>。</p>
<p>[问题是什么呢？]<br>框架现在需要实例化这个不知道名字的子类，怎么new呢？[注释]这个动作叫做<code>dynamic creation</code><br>由于C++语言本身的限制，通过一个string变量来制定需要实例化对象的名字是禁止的。我们唯一能做的，就是预先设定好需要实例化的这个class，然后比较后期需要创建class的名字（string），如果string相同，则创建对应的class。可以看出，这个用来比较class name的string，也需要是预先设定好的。</p>
<p>除此之外，就算你的字符串比对成功匹配了，就算现在就是可以调用这个预先写好的new语句了，那这句new写在哪里呢？写框架的人可能有本事把这句话写死再框架代码里吗？不可能，显然必须是写在用户代码里的。写在用户代码里？难道让那个class自己new自己？是的，你没有听错。<br>但是可能吗？我框架连你得class都找不到，怎么去找你class里面写的new？况且，你都没有实例化，怎么调用new函数？</p>
<p>[解决方案]–&gt;隔一层<br>第一个问题，我不是没办法写死那个比较的string嘛？那我可以加一个中间物件，比如一个表，一个list。我去从这个表里吗取名字，而这个表，是deffer到用户那里去填写的。意思就是，我新派生了一个子类，于是我把我子类的名字（string）注册到那个表里面去，然后框架在需要new我的时候，就例行公事去那个表里面检查。good！解决第一个问题。<br>第二个问题，怎么new。这个简单，把这个new语句，写成<code>static方法</code>，则不用实例化也可调用。<br>那怎么调用呢？ 嗯。。。调用函数呢，需要函数的入口地址，对吧？要么，给class name，是一个入口。或者，直接给这个函数地址，也OK，对不？。。。。嗯，有点怪，然后呢？简单啊，把这个自己创建自己的函数指针，直接放到前面提到的那张表里啊！查表，名字对上，取出自己new自己的函数地址，然后调用<code>用户写的</code>new语句，new出来的实例返回给框架，搞定！</p>
<p>[总结]<br>所谓“工厂方法”，指的是一套<code>接口</code>，包括框架维护的一个数据结构，让用户注册。以及用户自己书写的自己new自己的方法。（在框架的中，用户派生类的父类需要定义一个抽象函数强制要求用户定义这个函数。）<br>另外：这个“注册”和“自己创建自己”的动作，由于比较制式，经常由一个常规的宏函数实现（回想QT）。</p>
<hr>
<h4 id="Prototype"><a href="#Prototype" class="headerlink" title="Prototype"></a>Prototype</h4><p>Specify the kinds of objects to create using a prototypical instance, and create new objects by copying this prototype.<br>模板模式也是解决用户子类实例化的问题。但是我不能明白这么做的用意，可能是与工厂方法模式解决类似的问题。但是给出的例子，主要在客户端那边的实例化，不理解。</p>
<p>[什么意思呢]<br>prototype意思是原型，意思是，新定义的子类，在程序开始创建的时候，就<code>自动创建一个“原型”实例</code>，放在父类的容器里。虽然子类可以变化增加，但是因为父类是预先写好的嘛，如果想实例化子类，只要通过找到父类的容器里面的原型，就可以让这个原型new一个新的子类出来（美其名曰：clone函数，其实就是自己new自己）。好像是一个比较优雅的解法？不是嘛？～</p>
<p>[实现]</p>
<ol>
<li>首先，在程序启动时自动创建实例，能做到？可以的，叼的不行了。在子类定义里面，放一个static的自己（static就不算循环定义了？需要复习static）。然后static成员是有一次赋初值的机会的，写在class外面就行，这个动作不需要有人去手动调用它。于是这个初值就构造一个自己。（简直匪夷所思！）实例化好了对吧，然后更happy的来了，在构造函数里面，调用父类的某个函数，把自己放到父类的原型容器里去。天哪，代码还没开始跑，每个子类都已经各就各位了！</li>
<li>于是你也发现了，每个子类都会copy一份父类，如果这个容器不是static的，那么大家会在各自不同的容器里面，这就不happy了。</li>
<li>于是呢，用户拿到父类，容器在手，再无他求啊！</li>
<li>对于框架来说，也是可以通过父类的容器比对或者找到需要实例化的子类的。</li>
</ol>
<p>[另外]<br>具体实现时，常把子类的构造函数写为<code>私有</code>，这样做的想法，可能是想统一用父类的接口，不要让用户去处理子类。美其名曰：解偶。decouple。用户一切的子类创建必须通过父类的容器。</p>
<p>总之呢，是不太理解这个设计模式啦。。。只是觉得手段很精妙！</p>
<hr>
<h4 id="Reference-Counting"><a href="#Reference-Counting" class="headerlink" title="Reference Counting"></a>Reference Counting</h4><p>引用计数，非GOF的23个设计模式之一。主要的目的就是想省内存，即对于需要<code>深拷贝</code>来管理内存的物件，使用<code>写时复制</code>(copy on write)的技术，让用户看上去是深拷贝，而实际上是浅拷贝。只有当用户对拷贝的物件实际进行修改动作时，才真正深拷贝。</p>
<p>[应用]<br>STL的string。swift里面好像都是引用计数啊，还有vfork不知道是不是。<br>另外，引用计数在内存管理中也用到。没有指针指向自己时自动销毁。</p>
<p>[困难]-&gt;我怎么知道有几个人持有指向我的指针呢？<br>一个比较自然的想法，是搞一个用户列表在我自己的这个class里面，每个实例拥有一个表(不要搞成static)，这个表里面纪录着持有自己的对象。</p>
<p>这样做可以达到目的，但是对于使用者来说，需要增加额外的操作，比如在拷贝时，要去你的表里面增加自己，或者在销毁时，检查自己是不是表里面的最后一个，等等。<br>同时也不能做到自己销毁自己。</p>
<p>[解决]<br>我们又想到可以再包装一层，把<code>实际的value</code>与<code>对引用的manager</code>分成两个class，以string为例，把实际的字符串内容单独写到一个class里面，同时这个class再附加一个int字段来纪录自己的引用者。（这样与上面的table做法相比更省事）<br>而另外一个manager，则持有一个value类的引用，让外界持有这个manager，然后这个manager对外只要表现的像一个实际的value就行了（重载相关操作符嘛）。<br>当这个manager被copy时，仅仅做对manager的浅copy，然后让value类的引用计数＋1即可。同样的，manager销毁时，检查value类的引用计数，如果是1，那么除了销毁自己，顺手也把value类销毁掉。</p>
<p>[那么问题来了]-&gt;这样的浅copy，用户是不知道的，如果被改动不是错误了嘛？<br>是的，我们需要实现<code>copy_on_write</code>。<br>那么，我们怎么知道别人要write我了呢？还是重载操作符，对于可能<code>暴露自己handler</code>的，或者<code>直接修改</code>自己的，全都copy一份，再进行相应操作即可。</p>
<p>[问题]<br>你可能注意到了，上面需要真实copy的情况，直接修改自己是没商量的，而对于暴露自己handler的情况，可能用户并没有要修改，此时盲目copy造成资源浪费。但是对于C++语言功能来说，在传出自己handler时，并不能用户是否要进行修改，以决定是否要copy。只能是悲观得认为用户要改，保守操作。</p>
<p>这个问题可用proxy解决。</p>
<hr>
<h4 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h4><p>Provide a surrogate or placeholder for another object to <code>control access to it</code>.<br>[注释]surrogate：代理人<br>我觉得代理人模式也是又deffering的意思，我们不是直接对某个目标物件操作，而是通过这个proxy类来获取、操作目标物件。</p>
<p>有点属性值里面的setter和getter的意思，对代理操作，然后进行相关处理后，再又代理对实际的值进行处理。<br>这样多了一个中间层，可以有很多机会判断。比如在需要的时候再实例化目标啊之类的。</p>
<p>[另外]<br>对于上面引用计数不能解决的问题。（即暴露handler时无法判断用户是不是要修改）。我们可以不返回真实的value类出去，而是返回一个proxy给用户，也是表现的像一个value就行了。然后当这个proxy被修改的时候，再进行真实的copy。这样问题就解决了。</p>
<hr>
<h4 id="总结和反思"><a href="#总结和反思" class="headerlink" title="总结和反思"></a>总结和反思</h4><p>学完了这门课，给我最深刻的印象是，反反复复出现的<code>中间层</code>和<code>统一化</code>的思想。<br>中间层，把变化的、不确定的、暂时不知道的情况，先放置一个中间层，一端确定下来。然后把剩下的另一端不确定的，<code>推迟</code>到实际确定的时候再写清楚。或者一端确定，另一端发生的变化，并不会影响确定的那一端。<br>统一化的处理，可以大大简化工程的难度。</p>
<hr>
<h4 id="关于语言的零散笔记"><a href="#关于语言的零散笔记" class="headerlink" title="关于语言的零散笔记"></a>关于语言的零散笔记</h4><p>C++中reference的实现底层用的指针</p>
<p>java的方法全是虚函数，class全是引用</p>
<p>什么时候需要用虚函数？<br>设计父类时，如果某个方法需要由子类定义，或重新定义，那么应该被设计为虚函数</p>
<p>临时对象的生存期？待深入</p>
<p>java容器能放所有类型，是因为java有单根的继承体系，指向根的指针能指向任何类型</p>
<p>关于const成员函数<br>非const的class，也可以调用const的成员函数。但是会优先调用非const版本。</p>
<p>静态成员变量不会增加实例的size</p>
<p>变量最好在使用的前一刻再定义，特别是迭代器<br>比如：容器空间不够时，会重新分配一块空间（搬家），原来的迭代器指向的内存可能已经废弃。</p>
<p>operator char() const;   //这是重载的类型转换函数，当环境需要char类型时，它调用此函数。注意没有返回值，因为一定是char</p>
<hr>
<h4 id="附录：GOF的23种设计模式"><a href="#附录：GOF的23种设计模式" class="headerlink" title="附录：GOF的23种设计模式"></a>附录：GOF的23种设计模式</h4><p>_</p>
<h5 id="Creational-Patterns"><a href="#Creational-Patterns" class="headerlink" title="Creational Patterns"></a>Creational Patterns</h5><p><strong>Abstract Factory:</strong><br><em>Provide an interface for creating families of related or dependent objects without specifying their concrete classes.</em><br>提供一个创建一系列相关或相互依赖对象的接口,而无需指定它们具体的类。</p>
<p><strong>Builder:</strong><br><em>Separate the construction of a complex object from its representation so that the same construction process can create different representations.</em><br>将一个复杂对象的构建与它的表示分离，这样使得同样的构建过程可以创建不同的表示。</p>
<p><strong>Factory Method:</strong><br><em>Define an interface for creating an object, but let subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses.</em><br>定义一个用于创建对象的接口，让子类决定将哪一个类实例化。工厂方法模式使一个类的实例化延迟到子类。</p>
<p><strong>Prototype:</strong><br><em>Specify the kinds of objects to create using a prototypical instance, and create new objects by copying this prototype.</em><br>用原型实例指定创建对象的种类,并且通过拷贝这个原型来创建新的对象。</p>
<p><strong>Singleton:</strong><br><em>Ensure a class only has one instance, and provide a global point of access to it.</em><br>保证一个类仅有一个实例,并提供一个访问它的全局访问点。</p>
<h5 id="Structual-Patterns"><a href="#Structual-Patterns" class="headerlink" title="Structual Patterns"></a>Structual Patterns</h5><p><strong>Adapter:</strong><br><em>Convert the interface of a class into another interface clients expect. Adapter lets classes work together that couldn’t otherwise because of incompatible interfaces.</em><br>将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p>
<p><strong>Bridge:</strong><br><em>Decouple an abstraction from its implementation so that the two can vary independently.</em><br>将抽象部分与它的实现部分分离,使它们都可以独立地变化。</p>
<p><strong>Composite:</strong><br><em>Compose objects into tree structures to represent part-whole hierarchies. Composite lets clients treat individual objects and compositions of objects uniformly.</em><br>把物件组合成树形结构，以表示“部分－整体”的层次结构。复合模式使得用户一致地对待复合物件和单一物件。</p>
<p><strong>Decorator:</strong><br><em>Attach additional responsibilities to an object dynamically. Decorators provide a flexible alternative to subclassing for extending functionality.</em><br>將額外的「职责、任務、负担」以动态方式附著於物件身上,使不必進行subclassing就能扩展功能。</p>
<p><strong>Facade:</strong><br><em>Provide a unified interface to a set of interfaces in a subsystem. Facade defines a higher-level interface that makes the subsystem easier to use.</em><br>为子系统中的一组接口提供一个一致的界面,Facade模式定义了一个高层接口,这个接口使得这一子系统更加容易使用。</p>
<p><strong>Proxy:</strong><br><em>Provide a surrogate or placeholder for another object to control access to it.</em><br>为其他对象提供一个代理以控制对这个对象的访问。</p>
<h5 id="Behavioral-Patterns"><a href="#Behavioral-Patterns" class="headerlink" title="Behavioral Patterns"></a>Behavioral Patterns</h5><p><strong>Chain of Responsibility:</strong><br><em>Avoid coupling the sender of a request to its receiver by giving more than one object a chance to handle the request. Chain the receiving objects and pass the request along the chain until an object handles it.</em><br>为解除请求的发送者和接收者之间耦合,而使多个对象都有机会处理这个请求。将这些对象连成一条链,并沿着这条链传递该请求,直到有一个对象处理它。</p>
<p><strong>Command:</strong><br><em>Encapsulate a request as an object, thereby letting you parameterize clients with different requests, queue or log requests, and support undoable operations.</em><br>将一个请求封装为一个对象,从而使你可用不同的请求对客户进行参数化;对请求排队或记录请求日志,以及支持可取消的操作。</p>
<p><strong>Interpreter:</strong><br><em>Given a language, define a represention for its grammar along with an interpreter that uses the representation to interpret sentences in the language.</em><br>给定一个语言,定义它的文法的一种表示,并定义一个解释器,该解释器使用该表示来解释语言中的句子。</p>
<p><strong>Iterator:</strong><br><em>Provide a way to access the elements of an aggregate object sequentially without exposing its underlying representation.</em><br>提供一种方法顺序访问一个聚合对象中各个元素,而又不需暴露该对象的内部表示。</p>
<p><strong>Mediator:</strong><br><em>Define an object that encapsulates how a set of objects interact. Mediator promotes loose coupling by keeping objects from referring to each other explicitly, and it lets you vary their interaction independently.</em><br>用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用,从而使其耦合松散,而且可以独立地改变它们之间的交互。</p>
<p><strong>Memeneto:</strong><br><em>Without violating encapsulation, capture and externalize an object’s internal state so that the object can be restored to this state later.</em><br>在不破坏封装性的前提下,捕获一个对象的内部状态,并在该对象之外保存这个状态。这样以后就可将该对象恢复到保存的状态。</p>
<p><strong>Observer:</strong><br><em>Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.</em><br>定义对象间的一种一对多的依赖关系,以便当一个对象的状态发生改变时,所有依赖于它的对象都得到通知并自动刷新。</p>
<p><strong>State:</strong><br><em>Allow an object to alter its behavior when its internal state changes. The object will appear to change its class.</em><br>允许一个对象在其内部状态改变时改变它的行为。让这个对象看起来似乎修改了它所属的类。</p>
<p><strong>Strategy:</strong><br><em>Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it.</em><br>定义一系列的算法,把它们一个个封装起来,并且使它们可相互替换。本模式使得算法的变化可独立于使用它的客户。</p>
<p><strong>Template Method:</strong><br><em>Define the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm’s structure.</em><br>定义一个操作中的算法的骨架,而将一些步骤延迟到子类中。Template Method使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p>
<p><strong>Visitor:</strong><br><em>Represent an operation to be performed on the elements of an object structure. Visitor lets you define a new operation without changing the classes of the elements on which it operates.</em><br>表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</p>
</div></article></div></section><footer><div class="paginator"><a href="/2015/05/16/鼠须管配置指南/" class="prev">PRVE</a><a href="/2015/02/14/域名配置/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2016 <a href="http://Rocklu.me">Rock Lu</a>, unless otherwise noted.</p></div></footer><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script></body></html>