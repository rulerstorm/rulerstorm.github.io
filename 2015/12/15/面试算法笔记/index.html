<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 面试算法笔记 · Rock's personal notebook</title><meta name="description" content="面试算法笔记 - Rock Lu"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/u/1565858217" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/rulerstorm" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li><li class="nav-list-item"><a href="/impress/index.html" target="_self" class="nav-list-link">TEST</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">面试算法笔记</h1><div class="post-time">Dec 15, 2015</div><div class="post-content"><p>记录一些经典的算法问题，希望举一反三。</p>
<a id="more"></a>
<h4 id="2-sum问题"><a href="#2-sum问题" class="headerlink" title="2-sum问题"></a>2-sum问题</h4><p>_</p>
<h5 id="问题简述："><a href="#问题简述：" class="headerlink" title="问题简述："></a>问题简述：</h5><p>给定一个值，在一组数字中，找出两个数，加起来的和等于这个给定的值。</p>
<h5 id="常规思路："><a href="#常规思路：" class="headerlink" title="常规思路："></a>常规思路：</h5><p>挨个取出元素，再与其他值挨个相加，判断是否等于需要的值。<br>「复杂度」：O(n2)</p>
<h5 id="好思路-hash优化"><a href="#好思路-hash优化" class="headerlink" title="好思路-hash优化"></a>好思路-hash优化</h5><p>取出元素后，并不需要与所有的其他值相加，只需要查找是否存在等于<code>「目标值-当前值」</code>的元素。鉴于「线性查找」的复杂度较大，把元素存入hash表后再进行查找即可做到常数级时间复杂度。故总体的复杂度为O(n)。</p>
<p>总结：对于算法中某个步骤涉及到「查找」的，可用hash<code>空间换时间</code>。</p>
<h5 id="好思路-先排序再找"><a href="#好思路-先排序再找" class="headerlink" title="好思路-先排序再找"></a>好思路-先排序再找</h5><p>先对所有元素进行排序，然后用双指针一头一尾。加起来偏大就移尾巴，加起来偏小就移头。迭代多次后可以找到需要的两个数。<br>「复杂度」：O(nlogn) + O(n) = O(nlogn)</p>
<p>「我的疑问」：这样子，不会跑过头吗？那会不会尾巴尾巴一直加加加过头了？<br>「答」：不会。因为如果一直偏小，尾巴指针到达较小的那个数时，这时加起来的「和」一定就大于目标了，所以这时一定会是头部指针移动，尾巴指针停在那个位置。除非不存在这两个数，那么两个指针会相遇。</p>
<p>总结：对数据进行预处理，在计算复杂度时是与后续步骤<code>「相加」</code>的，那就只会取一个较大的值。相对于复杂的算法（相乘）会比较划算。</p>
<hr>
<h4 id="KMP简要思路"><a href="#KMP简要思路" class="headerlink" title="KMP简要思路"></a>KMP简要思路</h4><p>在字符串匹配中，KMP解决暴力法中「指针回溯」的问题（复杂度O(M*N)），做到线性复杂度。但是理解起来有点困难，核心点是以下两个：</p>
<ol>
<li>对于<code>各不相同</code>的pattern串，前一次比较时与目标串匹配的这些字符，<code>一定不可能和pattern「首字符」相同</code>，因为「首字符」不等于「后面的字符」，而这些字符与pattern串「后面的字符」已经匹配相同，所以这些都不用比较，首字符就不匹配了。</li>
<li>对于<code>后面有与首字符相同</code>的情况，上面的假设就不成立了。既然pattern串前后有相同，那就要从首次相同的位置再次进行比较。所以我们在KMP算法中的next数组是<code>这个位置往前的「最长首尾相同字串」</code>。最后，因为既然已经知道这几个字串是相同的，那也不用比较了，直接从下一个位置开始就好了。</li>
</ol>
<p>「另外」next数组的意思是什么？<br>直观的理解，next数组的每个元素，表示当匹配到这个元素不相等时，与目标串位置<code>下一个</code>参加比较的pattern串的「下标」。（未验证）</p>
<h5 id="KMP的最坏情况"><a href="#KMP的最坏情况" class="headerlink" title="KMP的最坏情况"></a>KMP的最坏情况</h5><p>pattern串中大量相等时（最差是全部相等），next数组值会越来越大。导致效率降低（复杂度上界为O(2N)）。<br>「解决」改进的KMP，就是计算next数组时，如果发现next到的元素与当前元素相同，那就肯定不会匹配成功，那就跳过它，直接比较next元素的next就好了。在数组中，就表现为：<br><code>若P[next[i]]==P[i];</code><br>=&gt;<br><code>则next[i]=next[next[i]]</code></p>
<p>「注意」KMP远没有那么简单，书中还设计到「自动机理论」，实际算法中求next数组算法也非常精妙。有待补充深入。</p>
<hr>
</div></article></div></section><footer><div class="paginator"><a href="/2015/12/22/C++的本质/" class="prev">上一篇</a><a href="/2015/12/02/牛顿迭代法/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2016 <a href="http://Rocklu.me">Rock Lu</a>, unless otherwise noted.</p></div></footer><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script></body></html>